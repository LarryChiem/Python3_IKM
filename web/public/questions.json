[
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(type(3/2))",
    "options": [
      "<class 'int'>",
      "<class 'float'>",
      "<class 'decimal.Decimal'>",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. / always returns a float in Python 3.",
      "1": "Correct. 3/2 evaluates to 1.5 (float).",
      "2": "Wrong. Decimal is only used if explicitly created.",
      "3": "Wrong. No exception is raised."
    }
  },
  {
    "topic": "Basics",
    "prompt": "Which statement about '==' and 'is' is TRUE?",
    "options": [
      "'is' compares values",
      "'==' compares identity",
      "'==' compares values; 'is' compares identity",
      "They are interchangeable"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. 'is' checks identity (same object).",
      "1": "Wrong. '==' checks value equality.",
      "2": "Correct. Value vs identity is the key distinction.",
      "3": "Wrong. They are not interchangeable."
    }
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nprint(0.1 + 0.2 == 0.3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on OS"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Floating-point rounding prevents exact equality here.",
      "1": "Correct. 0.1+0.2 is not exactly 0.3 in binary floating point.",
      "2": "Wrong. No exception is raised.",
      "3": "Wrong. This behavior is consistent across platforms."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "Which values are falsy in Python? (Select ALL that apply)",
    "options": [
      "0",
      "''",
      "[]",
      "'0'"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanations": {
      "0": "Correct. Numeric zero is falsy.",
      "1": "Correct. Empty string is falsy.",
      "2": "Correct. Empty list is falsy.",
      "3": "Wrong. Non-empty strings are truthy even if they look like zero."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint(bool([0]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Any non-empty list is truthy.",
      "1": "Wrong. The list is not empty.",
      "2": "Wrong. bool(list) is valid.",
      "3": "Wrong. bool returns True/False."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "Which are valid dictionary keys? (Select ALL that apply)",
    "options": [
      "('a', 1)",
      "['a', 1]",
      "{'a': 1}",
      "42"
    ],
    "correct": [
      0,
      3
    ],
    "explanations": {
      "0": "Correct. Tuples are hashable if elements are hashable.",
      "1": "Wrong. Lists are mutable → unhashable.",
      "2": "Wrong. Dicts are mutable → unhashable.",
      "3": "Correct. Integers are hashable."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2,3]\ny = x\nx.append(4)\nprint(y)",
    "options": [
      "[1,2,3]",
      "[1,2,3,4]",
      "[4]",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y references the same list as x.",
      "1": "Correct. Both variables point to the same list object.",
      "2": "Wrong. append mutates the list; it doesn’t replace it with [4].",
      "3": "Wrong. No variable is missing."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2,3]\ny = x[:]\nx.append(4)\nprint(y)",
    "options": [
      "[1,2,3,4]",
      "[1,2,3]",
      "[]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y is a copy; it doesn't see x's append.",
      "1": "Correct. Slicing creates a shallow copy of the list.",
      "2": "Wrong. The copy contains elements.",
      "3": "Wrong. This is valid Python."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = (1)\nprint(type(x))",
    "options": [
      "<class 'tuple'>",
      "<class 'int'>",
      "<class 'list'>",
      "<class 'float'>"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Parentheses alone do not make a tuple.",
      "1": "Correct. (1) is just the integer 1.",
      "2": "Wrong. Lists use square brackets.",
      "3": "Wrong. No float conversion occurs."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = (1,)\nprint(type(x))",
    "options": [
      "<class 'tuple'>",
      "<class 'int'>",
      "<class 'list'>",
      "<class 'float'>"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. The trailing comma makes it a tuple.",
      "1": "Wrong. (1,) is not an int.",
      "2": "Wrong. Not a list.",
      "3": "Wrong. Not a float."
    }
  },
  {
    "topic": "Generators",
    "prompt": "Which create a generator? (Select ALL that apply)",
    "options": [
      "(x for x in range(3))",
      "[x for x in range(3)]",
      "def f():\n    yield 1",
      "{x for x in range(3)}"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. Generator expression.",
      "1": "Wrong. List comprehension creates a list.",
      "2": "Correct. 'yield' makes a generator function.",
      "3": "Wrong. Set comprehension creates a set."
    }
  },
  {
    "topic": "Generators",
    "prompt": "What happens when a generator is exhausted?",
    "options": [
      "Returns None",
      "Restarts automatically",
      "Raises StopIteration",
      "Loops forever"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. It doesn’t return None to signal end.",
      "1": "Wrong. Generators do not restart on their own.",
      "2": "Correct. Iteration ends via StopIteration.",
      "3": "Wrong. It terminates."
    }
  },
  {
    "topic": "Sets",
    "prompt": "What is the result of: len({1,2,2,3})",
    "options": [
      "4",
      "3",
      "2",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Duplicates are removed.",
      "1": "Correct. The set is {1,2,3}.",
      "2": "Wrong. There are three unique elements.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Pitfalls",
    "prompt": "What does this print?\n\nprint([[]] * 2)",
    "options": [
      "[[], []] independent lists",
      "[[]] twice",
      "Two references to the same inner list",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. The inner list is shared (same object repeated).",
      "1": "Wrong. It becomes a list of length 2, not a nested repetition conceptually.",
      "2": "Correct. List multiplication repeats references to the same object.",
      "3": "Wrong. No error."
    }
  },
  {
    "topic": "Functions",
    "prompt": "Which statement about default arguments is TRUE?",
    "options": [
      "Evaluated at call time",
      "Evaluated once at function definition",
      "Reset every call",
      "Must be immutable"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Defaults are evaluated when the def runs (definition time).",
      "1": "Correct. This is why mutable defaults can be dangerous.",
      "2": "Wrong. They persist across calls.",
      "3": "Wrong. They can be mutable; it’s just often a pitfall."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(x, acc=[]):\n    acc.append(x)\n    return acc\n\nprint(f(1))\nprint(f(2))",
    "options": [
      "[1] then [2]",
      "[1] then [1, 2]",
      "[1] then [1]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. acc is the same list each call.",
      "1": "Correct. The default list is reused and grows.",
      "2": "Wrong. It doesn’t reset automatically.",
      "3": "Wrong. Valid code."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 10\n\ndef g():\n    x = 5\n\ng()\nprint(x)",
    "options": [
      "5",
      "10",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Local assignment does not affect global x.",
      "1": "Correct. The global x stays 10.",
      "2": "Wrong. No read-before-assign occurs here.",
      "3": "Wrong. x exists globally."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What happens?\n\nx = 1\n\ndef h():\n    print(x)\n    x = 2\n\nh()",
    "options": [
      "Prints 1",
      "Prints 2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python treats x as local due to assignment in the function.",
      "1": "Wrong. It fails before printing.",
      "2": "Correct. Local variable referenced before assignment.",
      "3": "Wrong. Name exists, but scope rules make it local."
    }
  },
  {
    "topic": "Scope",
    "prompt": "Which keyword allows assigning to a variable in an enclosing (non-global) scope?",
    "options": [
      "global",
      "nonlocal",
      "outer",
      "static"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. global targets module scope, not enclosing function scope.",
      "1": "Correct. nonlocal targets nearest enclosing function scope.",
      "2": "Wrong. Not a Python keyword.",
      "3": "Wrong. Not a Python keyword."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a' < 'B')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on locale"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Unicode code points put 'B' before 'a'.",
      "1": "Correct. 'B' has a smaller code point than 'a'.",
      "2": "Wrong. String comparisons are valid.",
      "3": "Wrong. Python uses Unicode code points, not locale."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What is the output?\n\nprint(','.join(['a', 'b', 'c']))",
    "options": [
      "a b c",
      "a,b,c",
      "['a','b','c']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. join uses the separator exactly (comma here).",
      "1": "Correct. Comma-separated string.",
      "2": "Wrong. That would be repr of a list, not join output.",
      "3": "Wrong. join works with strings."
    }
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "Which converts bytes to str using UTF-8?",
    "options": [
      "b.encode('utf-8')",
      "b.decode('utf-8')",
      "str(b)",
      "bytes(b)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. encode converts str -> bytes.",
      "1": "Correct. decode converts bytes -> str.",
      "2": "Wrong. str(b) produces a representation like \"b'...'\".",
      "3": "Wrong. bytes(b) expects an int iterable or buffer; not decoding."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('hello'[:3])",
    "options": [
      "hel",
      "ell",
      "llo",
      "IndexError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Slice from start up to index 3 (exclusive).",
      "1": "Wrong. That would be 'hello'[1:4].",
      "2": "Wrong. That would be 'hello'[2:5].",
      "3": "Wrong. Slicing is safe; no IndexError."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "Which statement about slicing is TRUE? (Select ALL that apply)",
    "options": [
      "Slicing a list returns a new list",
      "Slicing deep-copies nested objects",
      "Slicing supports a step value",
      "Slicing always returns a view"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. It creates a new list object (shallow copy).",
      "1": "Wrong. It’s a shallow copy; nested objects are shared.",
      "2": "Correct. list[start:stop:step] supports step.",
      "3": "Wrong. Python list slicing is not a view (unlike some libraries)."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = [1,2,3]\nx[1:2] = [9,9]\nprint(x)",
    "options": [
      "[1, 9, 3]",
      "[1, 9, 9, 3]",
      "[9, 9]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Replacing a slice can change length; here it inserts two items.",
      "1": "Correct. The slice [2] is replaced by [9,9].",
      "2": "Wrong. That would replace the whole list.",
      "3": "Wrong. Slice assignment is valid."
    }
  },
  {
    "topic": "Sorting",
    "prompt": "What does this print?\n\nprint(sorted(['10','2','1']))",
    "options": [
      "['1','2','10']",
      "['10','1','2']",
      "['10','2','1']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That would be numeric sort, but these are strings.",
      "1": "Correct. Lexicographic string order: '10' < '1' < '2' is false; actual is '10','1','2'.",
      "2": "Wrong. That’s the original order, not sorted.",
      "3": "Wrong. Sorting strings is valid."
    }
  },
  {
    "topic": "Sorting",
    "prompt": "How do you sort numbers by absolute value?",
    "options": [
      "sorted(nums, key=abs)",
      "sorted(abs(nums))",
      "nums.sort(abs)",
      "sort(nums, abs)"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. key=abs sorts by absolute value.",
      "1": "Wrong. abs(nums) is invalid for a list.",
      "2": "Wrong. list.sort takes keyword key=..., not a positional function like that.",
      "3": "Wrong. sort(...) is not a built-in function in that form."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does enumerate(iterable) produce?",
    "options": [
      "Only items",
      "Only indexes",
      "Pairs of (index, item)",
      "Triples of (index, item, length)"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. It includes indexes too.",
      "1": "Wrong. It includes items too.",
      "2": "Correct. enumerate yields (index, value) pairs.",
      "3": "Wrong. No length is included."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What is printed?\n\nprint(list(zip([1,2,3], ['a','b'])))",
    "options": [
      "[(1,'a'), (2,'b')]",
      "[(1,'a'), (2,'b'), (3,None)]",
      "TypeError",
      "[(1,'a'), (2,'b'), (3,'c')]"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. zip stops at the shortest iterable.",
      "1": "Wrong. zip does not pad with None by default.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. 'c' is not present."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "What does dict.get('k', 99) return if 'k' is missing?",
    "options": [
      "Raises KeyError",
      "Returns None always",
      "Returns 99",
      "Adds 'k' with 99"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. get does not raise KeyError.",
      "1": "Wrong. It returns default if provided.",
      "2": "Correct. Default is returned when key is missing.",
      "3": "Wrong. get does not mutate the dict."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "What does this print?\n\nd = {'a': 1}\nprint(d.setdefault('b', 2), d)",
    "options": [
      "2 {'a': 1, 'b': 2}",
      "None {'a': 1}",
      "KeyError",
      "2 {'a': 1}"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. setdefault inserts missing key and returns the value.",
      "1": "Wrong. It will insert 'b' and return 2.",
      "2": "Wrong. It does not raise KeyError.",
      "3": "Wrong. It mutates the dict by adding 'b'."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "Which module is typically used to encode/decode JSON?",
    "options": [
      "pickle",
      "json",
      "marshal",
      "csv"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. pickle is Python-specific serialization, not JSON.",
      "1": "Correct. The json module handles JSON encoding/decoding.",
      "2": "Wrong. marshal is low-level and not for JSON interchange.",
      "3": "Wrong. csv is for delimited text tables."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What is printed?\n\nprint(sum([1,2,3], 10))",
    "options": [
      "6",
      "13",
      "16",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That would be sum without a start value.",
      "1": "Wrong. 10+1+2+3 is not 13.",
      "2": "Correct. sum(iterable, start) starts from 10 → 16.",
      "3": "Wrong. This usage is valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(any([0, '', None, 5]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. any() returns True if any element is truthy (5 is truthy).",
      "1": "Wrong. There is a truthy element.",
      "2": "Wrong. This is valid input.",
      "3": "Wrong. any returns True/False."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(all([1, 'x', [], 3]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on order"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. [] is falsy, making all() False.",
      "1": "Correct. all() requires all elements truthy; [] is falsy.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. all evaluates deterministically."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "Which statement about try/else is TRUE?",
    "options": [
      "else runs only if an exception happens",
      "else runs only if no exception happens",
      "else always runs",
      "else replaces finally"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That’s the except block’s job.",
      "1": "Correct. try/else executes else when no exception occurs.",
      "2": "Wrong. else is conditional on no exception.",
      "3": "Wrong. finally has a different role."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What happens?\n\ntry:\n    1/0\nfinally:\n    print('done')",
    "options": [
      "Prints done and continues normally",
      "Prints done then raises ZeroDivisionError",
      "Raises before printing",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The exception still occurs.",
      "1": "Correct. finally runs, then the exception propagates.",
      "2": "Wrong. finally prints before propagation.",
      "3": "Wrong. Syntax is valid."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "Inside an except block, what does 'raise' with no arguments do?",
    "options": [
      "Raises SyntaxError",
      "Re-raises the current exception",
      "Raises None",
      "Suppresses the exception"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's legal syntax in an except block.",
      "1": "Correct. It re-raises the active exception.",
      "2": "Wrong. It doesn't raise None.",
      "3": "Wrong. It does the opposite of suppressing."
    }
  },
  {
    "topic": "IO",
    "prompt": "Which is TRUE about 'with open(...) as f:'?",
    "options": [
      "It disables buffering",
      "It always loads the file into memory",
      "It automatically closes even if errors happen",
      "It prevents exceptions"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Buffering behavior depends on mode and params.",
      "1": "Wrong. You still read explicitly.",
      "2": "Correct. Context manager closes file on exit.",
      "3": "Wrong. Exceptions can still occur."
    }
  },
  {
    "topic": "IO",
    "prompt": "Which mode opens a file for appending text?",
    "options": [
      "'r'",
      "'w'",
      "'a'",
      "'rb'"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. 'r' is read mode.",
      "1": "Wrong. 'w' truncates and writes.",
      "2": "Correct. 'a' appends to the end.",
      "3": "Wrong. 'rb' is read-binary."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does @staticmethod do?",
    "options": [
      "Passes instance as first arg",
      "Passes class as first arg",
      "No implicit first argument",
      "Makes method private"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That’s normal instance methods.",
      "1": "Wrong. That’s @classmethod.",
      "2": "Correct. staticmethod has no implicit self/cls.",
      "3": "Wrong. Python has no true private methods via decorator."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does @classmethod receive as its first argument?",
    "options": [
      "self",
      "cls",
      "both self and cls",
      "nothing"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. self is for instance methods.",
      "1": "Correct. cls is the class object.",
      "2": "Wrong. It receives only cls implicitly.",
      "3": "Wrong. It does receive cls."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What is printed?\n\nclass A:\n    def f(self):\n        return 'A'\n\nclass B(A):\n    def f(self):\n        return super().f() + 'B'\n\nprint(B().f())",
    "options": [
      "A",
      "B",
      "AB",
      "BA"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. B overrides f and adds 'B'.",
      "1": "Wrong. It includes A's result too.",
      "2": "Correct. super().f() returns 'A', then + 'B' → 'AB'.",
      "3": "Wrong. Order is A then B."
    }
  },
  {
    "topic": "OOP",
    "prompt": "If a class defines __len__ returning 0 and no __bool__, what is bool(obj)?",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends only on __bool__"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __len__ of 0 makes it falsy.",
      "1": "Correct. Python uses __len__ when __bool__ is absent.",
      "2": "Wrong. __len__ returning int is valid.",
      "3": "Wrong. __len__ also affects truthiness."
    }
  },
  {
    "topic": "OOP",
    "prompt": "Which special method enables obj[index]?",
    "options": [
      "__getitem__",
      "__getattr__",
      "__index__",
      "__slice__"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __getitem__ is used for indexing.",
      "1": "Wrong. __getattr__ handles missing attributes.",
      "2": "Wrong. __index__ is for converting an object to an integer index.",
      "3": "Wrong. __slice__ is not used like this in modern Python."
    }
  },
  {
    "topic": "Functional",
    "prompt": "What is the output?\n\nprint(list(map(lambda x: x*x, [1,2,3])))",
    "options": [
      "[1, 4, 9]",
      "[1, 2, 3]",
      "<map object ...>",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. map applies the function to each element.",
      "1": "Wrong. That would be identity function behavior.",
      "2": "Wrong. list(...) forces evaluation; without list it would show a map object.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Functional",
    "prompt": "What does this print?\n\nprint(list(filter(None, [0, 1, '', 'a'])))",
    "options": [
      "[0, 1, '', 'a']",
      "[1, 'a']",
      "['a']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. filter(None, ...) removes falsy values.",
      "1": "Correct. 0 and '' are falsy; 1 and 'a' remain.",
      "2": "Wrong. 1 is also truthy so it remains too.",
      "3": "Wrong. This is valid usage."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "What is the output?\n\nx = {'a': 1, 'b': 2}\nprint(list(x))",
    "options": [
      "['a', 'b'] (in insertion order)",
      "['a', 1, 'b', 2]",
      "[('a',1), ('b',2)]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Iterating a dict yields its keys (in insertion order in modern Python).",
      "1": "Wrong. Iteration does not yield values inline.",
      "2": "Wrong. That would be list(x.items()).",
      "3": "Wrong. list(dict) is valid."
    }
  },
  {
    "topic": "Concurrency",
    "prompt": "Which is TRUE about the Python's Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "It prevents I/O concurrency entirely",
      "It prevents true parallel execution of CPU-bound Python bytecode in threads",
      "It prevents multiprocessing from using multiple cores",
      "It makes asyncio impossible"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. I/O-bound threads can still overlap while waiting on I/O.",
      "1": "Correct. CPU-bound threads won’t run Python bytecode in true parallel. (GIL) is a mutex that ensures only one thread executes Python bytecode at a time in CPython, the standard Python implementation.",
      "2": "Wrong. multiprocessing uses separate processes and can use multiple cores.",
      "3": "Wrong. asyncio is cooperative and works fine."
    }
  },
  {
    "topic": "Concurrency",
    "prompt": "What does 'await' require on the right-hand side?",
    "options": [
      "A normal function",
      "An awaitable (coroutine/future/task)",
      "Only a generator",
      "A thread object"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Normal functions return values immediately; not awaitable.",
      "1": "Correct. await works with awaitables.",
      "2": "Wrong. Generators are not awaitables unless wrapped/converted.",
      "3": "Wrong. Threads are not awaitables by default."
    }
  },
  {
    "topic": "Typing",
    "prompt": "typing.Optional[int] means:",
    "options": [
      "int only",
      "int or None",
      "any type",
      "a required int"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Optional allows None.",
      "1": "Correct. Optional[int] == Union[int, None].",
      "2": "Wrong. That would be Any.",
      "3": "Wrong. Optional is the opposite of required-only."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\ns = 'abc'\ntry:\n    s[0] = 'z'\nexcept Exception as e:\n    print(type(e).__name__)",
    "options": [
      "ValueError",
      "TypeError",
      "IndexError",
      "No output"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Not a ValueError.",
      "1": "Correct. Strings are immutable; item assignment raises TypeError.",
      "2": "Wrong. Index 0 is valid; immutability is the issue.",
      "3": "Wrong. The exception is caught and printed."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nprint([1,2] == [1,2], [1,2] is [1,2])",
    "options": [
      "True True",
      "True False",
      "False True",
      "False False"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Separate list literals are different objects → 'is' is False.",
      "1": "Correct. Values equal, identities differ.",
      "2": "Wrong. Equality is True here.",
      "3": "Wrong. Equality is True."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "Which statement about dict membership is TRUE?\n\n('x' in {'x': 1})",
    "options": [
      "Checks values for membership",
      "Checks keys for membership",
      "Raises TypeError",
      "Depends on hash seed"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 'in' on a dict checks keys, not values.",
      "1": "Correct. Dict membership tests keys.",
      "2": "Wrong. It's valid.",
      "3": "Wrong. Meaning is deterministic; hash seed doesn't change correctness."
    }
  },
  {
    "topic": "Decorators",
    "prompt": "What does this print?\n\ndef deco(f):\n    def wrapper(*a, **k):\n        return f(*a, **k) + 1\n    return wrapper\n\n@deco\ndef f():\n    return 10\n\nprint(f())",
    "options": [
      "10",
      "11",
      "TypeError",
      "wrapper"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The decorator modifies the function result.",
      "1": "Correct. wrapper calls f() (10) then adds 1.",
      "2": "Wrong. All operations are valid.",
      "3": "Wrong. It prints the return value, not the function object."
    }
  },
  {
    "topic": "Closures",
    "prompt": "What does this print?\n\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda: i)\n\nprint([f() for f in funcs])",
    "options": [
      "[0, 1, 2]",
      "[2, 2, 2]",
      "[3, 3, 3]",
      "Raises NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Late binding means lambdas read i when called, not when created.",
      "1": "Correct. i ends at 2, so all lambdas return 2.",
      "2": "Wrong. range(3) ends with i == 2.",
      "3": "Wrong. i exists in the enclosing scope at call time."
    }
  },
  {
    "topic": "Closures",
    "prompt": "How do you fix the late-binding issue in the previous code (best answer)?",
    "options": [
      "Use lambda i=i: i",
      "Use global i",
      "Convert i to str",
      "Use nonlocal i"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Default args capture the current value at definition time.",
      "1": "Wrong. global doesn't capture per-iteration values.",
      "2": "Wrong. Type conversion doesn't address binding.",
      "3": "Wrong. nonlocal is for assigning into enclosing scopes, not capturing loop values."
    }
  },
  {
    "topic": "Context Managers",
    "prompt": "What does this print?\n\nclass C:\n    def __enter__(self):\n        print('enter')\n        return 123\n    def __exit__(self, exc_type, exc, tb):\n        print('exit')\n        return True\n\nwith C() as x:\n    print(x)\n    1/0\nprint('after')",
    "options": [
      "enter\n123\nexit\nafter",
      "enter\n123\nexit",
      "enter\n123 then ZeroDivisionError",
      "enter\nexit then ZeroDivisionError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __exit__ returns True which suppresses the exception, then execution continues.",
      "1": "Wrong. It continues to print 'after' because exception is suppressed.",
      "2": "Wrong. Exception is suppressed due to return True in __exit__.",
      "3": "Wrong. The body prints x before the exception occurs."
    }
  },
  {
    "topic": "Iteration Protocol",
    "prompt": "Which statement is TRUE about iterators?",
    "options": [
      "Every iterable is an iterator",
      "An iterator must implement __iter__ and __next__",
      "__iter__ must return a new independent iterator each time",
      "Iterators can be restarted by calling iter(it)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Iterables produce iterators; they aren't necessarily iterators themselves.",
      "1": "Correct. That's the core iterator protocol.",
      "2": "Wrong. That's typical for iterables; iterators usually return themselves from __iter__.",
      "3": "Wrong. Most iterators are one-shot and cannot be restarted."
    }
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this produce?\n\n{x: x*x for x in [1,1,2]}",
    "options": [
      "{1: 1, 2: 4} (last wins)",
      "{1: 1, 1: 1, 2: 4}",
      "{1: 1, 2: 2}",
      "Raises ValueError for duplicate keys"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Dict keys are unique; later assignments overwrite earlier ones.",
      "1": "Wrong. Dicts cannot contain duplicate keys.",
      "2": "Wrong. Value for 2 should be 4.",
      "3": "Wrong. No error is raised."
    }
  },
  {
    "topic": "Dataclasses",
    "prompt": "What is TRUE about a frozen dataclass?",
    "options": [
      "It prevents rebinding of all variables",
      "It prevents attribute assignment (like immutability) after creation",
      "It deep-freezes nested mutable fields",
      "It cannot have default values"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It only affects dataclass instance attribute assignment, not variables outside.",
      "1": "Correct. Frozen prevents setting attributes after init.",
      "2": "Wrong. Nested objects can still be mutated if they are mutable.",
      "3": "Wrong. Frozen dataclasses can still have defaults."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    raise ValueError('x')\nexcept Exception as e:\n    print(type(e).__name__)\nelse:\n    print('else')\nfinally:\n    print('finally')",
    "options": [
      "ValueError\nfinally",
      "Exception\nelse\nfinally",
      "ValueError\nelse\nfinally",
      "ValueError only"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. except runs, else does not, finally always runs.",
      "1": "Wrong. The exception type printed is ValueError, not Exception.",
      "2": "Wrong. else doesn't run when an exception occurs.",
      "3": "Wrong. finally always runs."
    }
  },
  {
    "topic": "Imports",
    "prompt": "Which is TRUE about `import module` vs `from module import name`?",
    "options": [
      "They are identical in all cases",
      "`from module import name` binds `name` directly in the importing namespace",
      "`import module` binds all module attributes into globals",
      "`from module import name` prevents module code from executing"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. They bind different names in the importing scope.",
      "1": "Correct. The imported name is bound directly (no module prefix needed).",
      "2": "Wrong. `import module` binds the module object only.",
      "3": "Wrong. Module code still executes on first import."
    }
  },
  {
    "topic": "Async",
    "prompt": "What does `await` require?",
    "options": [
      "A regular function",
      "An awaitable (coroutine/future/task)",
      "A generator expression",
      "A thread object"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Regular functions are not awaitable.",
      "1": "Correct. await works with awaitables.",
      "2": "Wrong. Generators are not awaitables unless adapted.",
      "3": "Wrong. Threads are not awaitables by default."
    }
  },
  {
    "topic": "GIL",
    "prompt": "Which statement best describes the CPython GIL?",
    "options": [
      "Threads cannot be used at all",
      "Threads cannot run CPU-bound Python bytecode in true parallel",
      "Multiprocessing is also limited to one core",
      "Asyncio bypasses the GIL for CPU work"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Threads can be useful for I/O-bound workloads.",
      "1": "Correct. CPU-bound work doesn't gain true parallelism in threads under CPython.",
      "2": "Wrong. Multiprocessing uses multiple processes and can use multiple cores.",
      "3": "Wrong. Asyncio is cooperative; CPU work still blocks unless offloaded."
    }
  },
  {
    "topic": "Mutability",
    "prompt": "What does this print?\n\na = ([],)\na[0].append(1)\nprint(a)",
    "options": [
      "TypeError because tuple is immutable",
      "([],)",
      "([1],)",
      "Raises AttributeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. The tuple can't be rebound, but the list inside can be mutated.",
      "1": "Wrong. The list was appended to.",
      "2": "Correct. The list inside the tuple becomes [1].",
      "3": "Wrong. list.append exists."
    }
  },
  {
    "topic": "Descriptors",
    "prompt": "Which mechanism powers `@property`?",
    "options": [
      "Metaclasses only",
      "Descriptors (__get__/__set__)",
      "Monkey patching",
      "The GIL"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Metaclasses are not required for property.",
      "1": "Correct. property implements the descriptor protocol.",
      "2": "Wrong. Monkey patching is unrelated.",
      "3": "Wrong. The GIL is unrelated."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    x = 1\n\nclass B(A):\n    x = 2\n\nprint(A.x, B.x, B().x)",
    "options": [
      "1 1 1",
      "1 2 2",
      "2 2 1",
      "2 1 2"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. B overrides x.",
      "1": "Correct. A.x=1, B.x=2, instance finds B.x=2.",
      "2": "Wrong. A.x stays 1.",
      "3": "Wrong. A.x is not 2."
    }
  },
  {
    "topic": "Hashing",
    "prompt": "Why can a tuple be used as a dict key but a list cannot (in general)?",
    "options": [
      "Tuples are faster",
      "Lists are ordered",
      "Tuples are (generally) immutable and hashable; lists are mutable and unhashable",
      "Lists cannot contain strings"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Speed isn't the rule for hashability.",
      "1": "Wrong. Both are ordered sequences.",
      "2": "Correct. Mutability breaks hash invariants.",
      "3": "Wrong. Lists can contain strings."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What does Optional[int] mean?",
    "options": [
      "int only",
      "int or None",
      "any type",
      "a required int"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Optional includes None.",
      "1": "Correct. Optional[int] == Union[int, None].",
      "2": "Wrong. That would be Any.",
      "3": "Wrong. Optional suggests it can be None."
    }
  },
  {
    "topic": "Functional",
    "prompt": "What does this print?\n\nprint(list(filter(None, [0, 1, '', 'a', None])))",
    "options": [
      "[0, 1, '', 'a', None]",
      "[1, 'a']",
      "['a']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. filter(None, ...) removes falsy values.",
      "1": "Correct. Keeps truthy values: 1 and 'a'.",
      "2": "Wrong. 1 is also truthy.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Evaluation Order",
    "prompt": "What does this print?\n\nx = 0\nx = x + 1 if True else x + 100\nprint(x)",
    "options": [
      "0",
      "1",
      "100",
      "101"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The conditional expression takes the True branch.",
      "1": "Correct. True branch evaluates to x+1 (0+1).",
      "2": "Wrong. Else branch is not evaluated.",
      "3": "Wrong. Only one branch is evaluated."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What is the output?\n\nimport math\nprint(math.isclose(0.1 + 0.2, 0.3))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. isclose checks approximate equality with tolerances.",
      "1": "Wrong. isclose is designed for floating-point comparisons.",
      "2": "Wrong. This is valid usage.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Performance",
    "prompt": "Which is generally more memory-efficient for large sequences?",
    "options": [
      "List comprehension",
      "Generator expression",
      "Building a list then iterating",
      "Converting to tuple first"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Lists materialize all items immediately.",
      "1": "Correct. Generators produce items lazily.",
      "2": "Wrong. It creates the whole list in memory.",
      "3": "Wrong. Tuples still store all items."
    }
  },
  {
    "topic": "MRO",
    "prompt": "What determines method resolution order (MRO) in Python?",
    "options": [
      "Depth-first search",
      "Breadth-first search",
      "C3 linearization",
      "Order of class definition"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python does not use naive depth-first search.",
      "1": "Wrong. Breadth-first alone is insufficient.",
      "2": "Correct. Python uses C3 linearization for MRO.",
      "3": "Wrong. Definition order alone is not sufficient."
    }
  },
  {
    "topic": "MRO",
    "prompt": "What does this print?\n\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass\n\nprint(D.__mro__)",
    "options": [
      "(D, B, C, A, object)",
      "(D, C, B, A, object)",
      "(D, B, A, C, object)",
      "Raises TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. This follows C3 linearization.",
      "1": "Wrong. Order of bases is respected.",
      "2": "Wrong. A must come after both B and C.",
      "3": "Wrong. This hierarchy is valid."
    }
  },
  {
    "topic": "Descriptors",
    "prompt": "Which methods define the descriptor protocol?",
    "options": [
      "__get__ only",
      "__get__ and __set__",
      "__get__, __set__, and __delete__",
      "__call__"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Descriptors can define more than __get__.",
      "1": "Wrong. __delete__ is also part of the protocol.",
      "2": "Correct. These three define descriptor behavior (a mechanism that allows customizing attribute access, assignment, and deletion in classes by defining special methods in an object). ",
      "3": "Wrong. __call__ is unrelated."
    }
  },
  {
    "topic": "Descriptors",
    "prompt": "Which built-in feature relies on descriptors?",
    "options": [
      "for loops",
      "@property",
      "lambda",
      "try/except"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Iteration does not use descriptors.",
      "1": "Correct. property is implemented using descriptors (an object that implements one or more methods of the descriptor protocol — __get__(), __set__(), and __delete__()).",
      "2": "Wrong. Lambdas are functions.",
      "3": "Wrong. Exception handling is unrelated."
    }
  },
  {
    "topic": "Weak References",
    "prompt": "What is the purpose of weakref?",
    "options": [
      "Improve performance",
      "Prevent garbage collection",
      "Reference objects without preventing GC",
      "Make objects immutable"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. weakref is about lifecycle, not speed.",
      "1": "Wrong. weak references do not prevent GC.",
      "2": "Correct. weakref allows GC when no strong refs exist.",
      "3": "Wrong. It does not affect mutability."
    }
  },
  {
    "topic": "Garbage Collection",
    "prompt": "What does reference counting fail to handle without GC?",
    "options": [
      "Large objects",
      "Immutable objects",
      "Circular references",
      "Function calls"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Size is irrelevant.",
      "1": "Wrong. Immutability does not affect reference counting.",
      "2": "Correct. Cycles require cyclic garbage collection.",
      "3": "Wrong. Calls do not cause leaks."
    }
  },
  {
    "topic": "Contextlib",
    "prompt": "What does @contextmanager allow you to do?",
    "options": [
      "Create decorators",
      "Create generators",
      "Create context managers using yield",
      "Suppress exceptions globally"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. contextmanager is not for decorators in general.",
      "1": "Wrong. Though it uses yield, its purpose is context management.",
      "2": "Correct. yield splits enter and exit logic.",
      "3": "Wrong. Exception suppression is optional."
    }
  },
  {
    "topic": "Contextlib",
    "prompt": "If a contextmanager generator does not yield, what happens?",
    "options": [
      "Nothing",
      "RuntimeError",
      "StopIteration",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The context requires a yield.",
      "1": "Correct. A RuntimeError is raised.",
      "2": "Wrong. StopIteration is internal.",
      "3": "Wrong. Syntax is valid."
    }
  },
  {
    "topic": "Functools",
    "prompt": "What does functools.lru_cache do?",
    "options": [
      "Caches results of function calls",
      "Caches function bytecode",
      "Optimizes recursion only",
      "Makes functions thread-safe"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Results are memoized based on arguments.",
      "1": "Wrong. Bytecode is not cached this way.",
      "2": "Wrong. It works for any function.",
      "3": "Wrong. Thread safety is not guaranteed."
    }
  },
  {
    "topic": "Functools",
    "prompt": "What happens when lru_cache reaches maxsize?",
    "options": [
      "Cache clears entirely",
      "Oldest entries are evicted",
      "Newest entries are evicted",
      "Raises MemoryError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Cache is not fully cleared.",
      "1": "Correct. Least recently used entries are evicted.",
      "2": "Wrong. New entries are retained.",
      "3": "Wrong. Eviction prevents memory errors."
    }
  },
  {
    "topic": "Itertools",
    "prompt": "Which itertools function groups consecutive items?",
    "options": [
      "groupby",
      "combinations",
      "product",
      "chain"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. groupby groups adjacent elements.",
      "1": "Wrong. combinations creates tuples.",
      "2": "Wrong. product computes Cartesian products.",
      "3": "Wrong. chain concatenates iterables."
    }
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.count() produce?",
    "options": [
      "A finite range",
      "An infinite iterator",
      "A list",
      "Raises StopIteration"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. count is unbounded.",
      "1": "Correct. It produces an infinite sequence.",
      "2": "Wrong. It yields values lazily.",
      "3": "Wrong. It never stops."
    }
  },
  {
    "topic": "Memory",
    "prompt": "Which object typically uses the least memory?",
    "options": [
      "List",
      "Tuple",
      "Set",
      "Dict"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Lists have extra capacity overhead.",
      "1": "Correct. Tuples are compact and immutable.",
      "2": "Wrong. Sets require hashing overhead.",
      "3": "Wrong. Dicts store key-value pairs."
    }
  },
  {
    "topic": "CPython Internals",
    "prompt": "What is Python bytecode?",
    "options": [
      "Machine code",
      "Intermediate representation executed by the VM",
      "Assembly language",
      "Source code"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Bytecode is not machine code.",
      "1": "Correct. Bytecode is run by the Python virtual machine.",
      "2": "Wrong. Assembly is lower-level.",
      "3": "Wrong. Bytecode is compiled from source."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "What is the primary purpose of the asyncio event loop?",
    "options": [
      "Run threads in parallel",
      "Schedule and run asynchronous tasks",
      "Replace the operating system scheduler",
      "Execute CPU-bound code faster"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. asyncio does not manage OS threads.",
      "1": "Correct. The event loop schedules and runs async tasks cooperatively.",
      "2": "Wrong. The OS scheduler is unchanged.",
      "3": "Wrong. Asyncio does not speed up CPU-bound work."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "What happens if you call an async function without awaiting it?",
    "options": [
      "It runs immediately",
      "It raises a SyntaxError",
      "It returns a coroutine object",
      "It blocks the event loop"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Async functions do not execute until awaited.",
      "1": "Wrong. This is syntactically valid.",
      "2": "Correct. Calling returns a coroutine object.",
      "3": "Wrong. Nothing runs yet."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "Which function is used to run the asyncio event loop in Python 3.7+?",
    "options": [
      "loop.run()",
      "asyncio.execute()",
      "asyncio.run()",
      "asyncio.start()"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. loop.run is not the public API.",
      "1": "Wrong. This function does not exist.",
      "2": "Correct. asyncio.run() is the recommended entry point.",
      "3": "Wrong. This function does not exist."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What does typing.Protocol enable?",
    "options": [
      "Runtime type enforcement",
      "Nominal subtyping",
      "Structural subtyping",
      "Duck typing removal"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Protocols are for static typing.",
      "1": "Wrong. Protocols avoid nominal inheritance.",
      "2": "Correct. Protocols enable structural (duck-typed) subtyping.",
      "3": "Wrong. Protocols formalize duck typing."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What is the runtime effect of type hints?",
    "options": [
      "They enforce types automatically",
      "They slow down execution",
      "They are mostly ignored at runtime",
      "They prevent invalid assignments"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python does not enforce types by default.",
      "1": "Wrong. They usually have no runtime cost.",
      "2": "Correct. Type hints are for tooling, not enforcement.",
      "3": "Wrong. Invalid assignments are still allowed."
    }
  },
  {
    "topic": "Metaclasses",
    "prompt": "When is a metaclass __new__ method executed?",
    "options": [
      "When an instance is created",
      "When a class is defined",
      "When a module is imported",
      "When __init__ is called"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Instance creation is handled later.",
      "1": "Correct. Metaclasses control class creation.",
      "2": "Wrong. Imports may trigger class definition, but not always.",
      "3": "Wrong. __init__ refers to instances."
    }
  },
  {
    "topic": "Metaclasses",
    "prompt": "Which keyword argument is passed to a metaclass __new__?",
    "options": [
      "self",
      "cls",
      "bases",
      "locals"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. self is for instances.",
      "1": "Wrong. cls refers to the metaclass itself.",
      "2": "Correct. bases contains base classes of the new class.",
      "3": "Wrong. locals are passed as a dict, not as this name."
    }
  },
  {
    "topic": "Imports",
    "prompt": "Where are imported modules cached?",
    "options": [
      "globals()",
      "builtins",
      "sys.modules",
      "__all__"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. globals only affect the current module.",
      "1": "Wrong. builtins is separate.",
      "2": "Correct. sys.modules caches loaded modules.",
      "3": "Wrong. __all__ controls export behavior."
    }
  },
  {
    "topic": "Imports",
    "prompt": "What happens if you delete an entry from sys.modules?",
    "options": [
      "The module is unloaded from memory",
      "The module cannot be imported again",
      "The next import reloads the module",
      "Python crashes"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Other references may still exist.",
      "1": "Wrong. It can be re-imported.",
      "2": "Correct. The next import reloads the module.",
      "3": "Wrong. This is safe (though advanced)."
    }
  },
  {
    "topic": "Multiprocessing",
    "prompt": "Why does multiprocessing bypass the GIL?",
    "options": [
      "It disables the GIL",
      "Each process has its own interpreter",
      "It rewrites Python bytecode",
      "It uses async IO"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The GIL still exists per process.",
      "1": "Correct. Each process has its own GIL.",
      "2": "Wrong. Bytecode is unchanged.",
      "3": "Wrong. Async IO is unrelated."
    }
  },
  {
    "topic": "Multiprocessing",
    "prompt": "What must be true for objects sent between processes?",
    "options": [
      "They must be hashable",
      "They must be immutable",
      "They must be picklable",
      "They must be threadsafe"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Hashability is irrelevant.",
      "1": "Wrong. Mutable objects can be pickled.",
      "2": "Correct. Objects are serialized via pickle (the process of serializing a Python object into a byte stream, allowing it to be saved to a file, transmitted over a network, or stored for later use).",
      "3": "Wrong. Thread safety is unrelated."
    }
  },
  {
    "topic": "Collections",
    "prompt": "What does collections.defaultdict provide?",
    "options": [
      "Automatic key deletion",
      "Default values for missing keys",
      "Thread safety",
      "Ordered iteration"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Keys are not deleted.",
      "1": "Correct. Missing keys are created automatically.",
      "2": "Wrong. defaultdict is not thread-safe.",
      "3": "Wrong. Order depends on insertion."
    }
  },
  {
    "topic": "Collections",
    "prompt": "What does collections.deque provide over list?",
    "options": [
      "Faster random access",
      "Efficient appends and pops from both ends",
      "Automatic sorting",
      "Lower memory usage in all cases"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Deque is not optimized for random access.",
      "1": "Correct. Deque is optimized for both ends.",
      "2": "Wrong. Deque does not sort.",
      "3": "Wrong. Memory usage varies."
    }
  },
  {
    "topic": "Evaluation",
    "prompt": "What does short-circuit evaluation mean?",
    "options": [
      "Expressions are evaluated faster",
      "Later operands may not be evaluated",
      "Evaluation happens in parallel",
      "Exceptions are suppressed"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Speed is not guaranteed.",
      "1": "Correct. Logical operators may skip evaluation.",
      "2": "Wrong. Evaluation is sequential.",
      "3": "Wrong. Exceptions are not suppressed."
    }
  },
  {
    "topic": "Evaluation",
    "prompt": "What does this print?\n\nprint(False and (1/0))",
    "options": [
      "False",
      "ZeroDivisionError",
      "None",
      "True"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. The second operand is never evaluated.",
      "1": "Wrong. Short-circuit prevents evaluation.",
      "2": "Wrong. The result is False.",
      "3": "Wrong. False and anything is False."
    }
  },
  {
    "topic": "Performance",
    "prompt": "Which is typically the fastest membership test?",
    "options": [
      "x in list",
      "x in tuple",
      "x in set",
      "x in string"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. List membership is O(n).",
      "1": "Wrong. Tuple membership is O(n).",
      "2": "Correct. Set membership is O(1) average case.",
      "3": "Wrong. Strings require scanning."
    }
  },
  {
    "topic": "Security",
    "prompt": "Why is eval() dangerous?",
    "options": [
      "It is slow",
      "It cannot evaluate expressions",
      "It can execute arbitrary code",
      "It leaks memory"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Speed is not the primary risk.",
      "1": "Wrong. eval can evaluate expressions.",
      "2": "Correct. eval executes arbitrary code.",
      "3": "Wrong. Memory leaks are not the main concern."
    }
  },
  {
    "topic": "Security",
    "prompt": "Which is safer than eval for parsing literals?",
    "options": [
      "exec",
      "compile",
      "ast.literal_eval",
      "globals"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. exec is also dangerous.",
      "1": "Wrong. compile does not restrict execution.",
      "2": "Correct. literal_eval safely parses literals only.",
      "3": "Wrong. globals exposes namespace."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(7 // 2)",
    "options": [
      "3.5",
      "3",
      "4",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's true division.",
      "1": "Correct. // is floor division, so 7//2 is 3.",
      "2": "Wrong. Floor division rounds down.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint(7 % 2)",
    "options": [
      "0",
      "1",
      "2",
      "3"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 7 isn't divisible by 2.",
      "1": "Correct. 7 mod 2 is 1.",
      "2": "Wrong. That's the divisor.",
      "3": "Wrong. That's too large for a remainder."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(type(True))",
    "options": [
      "<class 'bool'>",
      "<class 'int'>",
      "<class 'str'>",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. True is a bool.",
      "1": "Wrong. bool is a distinct type (though it's a subclass of int).",
      "2": "Wrong. It's not a string.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(2 ** 3 ** 2)",
    "options": [
      "512",
      "64",
      "16",
      "SyntaxError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. ** is right-associative: 2 ** (3 ** 2) = 2 ** 9 = 512.",
      "1": "Wrong. That's (2**3)**2.",
      "2": "Wrong. That's 2**4.",
      "3": "Wrong. This is valid syntax."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint('py' + 'thon')",
    "options": [
      "python  (with trailing space)",
      "python",
      "py thon",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Case/spacing matters.",
      "1": "Correct. String concatenation joins them with no extra characters.",
      "2": "Wrong. No space is inserted automatically.",
      "3": "Wrong. Concatenation of str is valid."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint('a' * 3)",
    "options": [
      "aaa",
      "a3",
      "'aaa'",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Repetition with * repeats the string.",
      "1": "Wrong. It repeats, it doesn't append the number.",
      "2": "Wrong. print shows the value, not repr with quotes.",
      "3": "Wrong. str * int is valid."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint(None is None)",
    "options": [
      "True",
      "False",
      "Depends on version",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. None is a singleton; identity comparison is True.",
      "1": "Wrong. There is only one None object.",
      "2": "Wrong. This is consistent.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(bool(''))",
    "options": [
      "True",
      "False",
      "None",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Non-empty strings are truthy; empty is falsy.",
      "1": "Correct. Empty string is falsy.",
      "2": "Wrong. bool returns True/False.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(int('010'))",
    "options": [
      "10",
      "8",
      "Raises ValueError",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. int() parses base-10 by default unless base is provided.",
      "1": "Wrong. Octal requires base=8 or 0o prefix.",
      "2": "Wrong. '010' is valid decimal.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(type(3//2))",
    "options": [
      "<class 'float'>",
      "<class 'int'>",
      "<class 'bool'>",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's for /.",
      "1": "Correct. Floor division of ints produces an int.",
      "2": "Wrong. It's an int, not bool.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint(bool({}))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Only non-empty containers are truthy.",
      "1": "Correct. An empty dict is falsy.",
      "2": "Wrong. bool({}) is valid.",
      "3": "Wrong. bool returns True/False."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint([] == False)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Equality isn't the same as truthiness.",
      "1": "Correct. [] is falsy, but it is not equal to False.",
      "2": "Wrong. Comparison is allowed.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(1 < 2 < 3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Chained comparisons work: 1<2 and 2<3.",
      "1": "Wrong. Both comparisons are True.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(1 < 2 > 3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 2 is not > 3.",
      "1": "Correct. It's (1<2) and (2>3); second part is False.",
      "2": "Wrong. Valid syntax.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "Which are falsy? (Select ALL that apply)",
    "options": [
      "set()",
      "{0}",
      "0.0",
      "'False'"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. Empty set is falsy.",
      "1": "Wrong. Non-empty set is truthy.",
      "2": "Correct. 0.0 is falsy (numeric zero).",
      "3": "Wrong. Non-empty strings are truthy."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint('5' == 5)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. '5' is a str.",
      "1": "Correct. Different types; no implicit conversion for ==.",
      "2": "Wrong. Comparing different types is allowed; it just returns False.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint('5' + str(5))",
    "options": [
      "10",
      "55",
      "'55'",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's numeric addition, not string concatenation.",
      "1": "Correct. '5' + '5' becomes '55'.",
      "2": "Wrong. print doesn't add quotes.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(5 == 5.0)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. int and float compare by numeric value; 5 == 5.0 is True.",
      "1": "Wrong. They are numerically equal.",
      "2": "Wrong. Comparison is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(5 is 5)",
    "options": [
      "Always True",
      "Always False",
      "Implementation detail; don't rely on it",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Not guaranteed.",
      "1": "Wrong. It can be True in CPython for small ints.",
      "2": "Correct. Small integer interning can make this True, but it's not guaranteed by the language spec.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint(5/2, 5//2)",
    "options": [
      "2.5 2",
      "2 2.5",
      "2.0 2",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. / gives 2.5, // gives 2.",
      "1": "Wrong. Order is / then //.",
      "2": "Wrong. 5/2 is 2.5 not 2.0.",
      "3": "Wrong. No exception."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({1,2,3} & {2,3,4})",
    "options": [
      "{1}",
      "{2, 3}",
      "{4}",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's the difference.",
      "1": "Correct. & is set intersection.",
      "2": "Wrong. 4 isn't in both sets.",
      "3": "Wrong. Set intersection is valid."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nd = {'a': 1}\nd['b'] = 2\nprint(d['b'])",
    "options": [
      "1",
      "2",
      "KeyError",
      "None"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's d['a'].",
      "1": "Correct. After assignment, d['b'] is 2.",
      "2": "Wrong. The key exists.",
      "3": "Wrong. Direct indexing returns the value, not None."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint(len({'a':1, 'a':2}))",
    "options": [
      "1",
      "2",
      "Raises ValueError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Duplicate keys overwrite; only one key remains.",
      "1": "Wrong. Dict keys are unique; duplicates collapse.",
      "2": "Wrong. No error; last assignment wins.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint(list({'a':1, 'b':2}.values()))",
    "options": [
      "['a','b']",
      "[1, 2]",
      "[('a',1),('b',2)]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's keys.",
      "1": "Correct. .values() yields the values.",
      "2": "Wrong. That's items().",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint([1,2,3][-1])",
    "options": [
      "1",
      "2",
      "3",
      "IndexError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That's first element.",
      "1": "Wrong. That's middle element.",
      "2": "Correct. -1 indexes the last element.",
      "3": "Wrong. -1 is valid index."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = [1,2,3]\nx.pop()\nprint(x)",
    "options": [
      "[1,2,3]",
      "[1,2]",
      "[2,3]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. pop mutates the list.",
      "1": "Correct. pop() removes and returns the last element.",
      "2": "Wrong. It removes from the end by default.",
      "3": "Wrong. pop() is valid."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = [1,2,3]\nprint(x.pop(0), x)",
    "options": [
      "1 [2, 3]",
      "3 [1, 2]",
      "1 [1, 2]",
      "IndexError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. pop(0) removes the first element and returns it.",
      "1": "Wrong. pop(0) targets index 0, not the end.",
      "2": "Wrong. It removes the element, it doesn't keep it.",
      "3": "Wrong. Index 0 exists."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "Which are valid ways to create an empty set? (Select ALL that apply)",
    "options": [
      "{}",
      "set()",
      "{1,2}",
      "{ }"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. {} creates an empty dict, not a set.",
      "1": "Correct. set() creates an empty set.",
      "2": "Wrong. This is a non-empty set.",
      "3": "Wrong. { } is the same as {}, an empty dict."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint(tuple([1,2,3]))",
    "options": [
      "[1, 2, 3]",
      "(1, 2, 3)",
      "{1, 2, 3}",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's still a list.",
      "1": "Correct. tuple(...) converts the list into a tuple.",
      "2": "Wrong. That's a set literal.",
      "3": "Wrong. This conversion is valid."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({} == dict())",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Both create empty dicts.",
      "1": "Wrong. They are equal.",
      "2": "Wrong. Comparison is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = {'a': 1}\ny = x.copy()\nx['a'] = 99\nprint(y['a'])",
    "options": [
      "99",
      "1",
      "KeyError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y is a separate dict.",
      "1": "Correct. copy() makes a shallow copy of the dict, so y keeps the old value for that key.",
      "2": "Wrong. Key exists in y.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = {'a': []}\ny = x.copy()\nx['a'].append(1)\nprint(y['a'])",
    "options": [
      "[]",
      "[1]",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The shared list was mutated.",
      "1": "Correct. copy() is shallow; both dicts share the same inner list.",
      "2": "Wrong. append is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({1,2,3} - {2})",
    "options": [
      "{1, 2}",
      "{1, 3}",
      "{2, 3}",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 2 is removed, not kept.",
      "1": "Correct. - is set difference: remove elements in the right set.",
      "2": "Wrong. 2 is removed.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({1,2} | {2,3})",
    "options": [
      "{1, 2}",
      "{2, 3}",
      "{1, 2, 3}",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Union includes 3.",
      "1": "Wrong. Union includes 1.",
      "2": "Correct. | is set union.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'.upper())",
    "options": [
      "ABC",
      "Abc",
      "abc",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. upper() returns an uppercase copy.",
      "1": "Wrong. uppercases all letters.",
      "2": "Wrong. It changes case.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'.find('d'))",
    "options": [
      "-1",
      "0",
      "1",
      "Raises ValueError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. find returns -1 when not found.",
      "1": "Wrong. 0 would mean found at start.",
      "2": "Wrong. 1 would mean found at index 1.",
      "3": "Wrong. find does not raise; index() would."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a,b,c'.split(','))",
    "options": [
      "['a','b','c']",
      "['a', 'b', 'c']",
      "a,b,c",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. print shows spaces after commas in list repr.",
      "1": "Correct. split returns a list of strings.",
      "2": "Wrong. split produces a list.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "What does this print?\n\nprint(b'hi' + b'!')",
    "options": [
      "b'hi!'",
      "'hi!'",
      "hi!",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Bytes concatenate to bytes.",
      "1": "Wrong. It's bytes, not str.",
      "2": "Wrong. print shows b'' for bytes.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "What converts str to bytes using UTF-8?",
    "options": [
      "s.decode('utf-8')",
      "s.encode('utf-8')",
      "bytes(s)",
      "str(s)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. decode is for bytes -> str.",
      "1": "Correct. encode converts str -> bytes.",
      "2": "Wrong. bytes(s) requires an encoding unless s is already bytes.",
      "3": "Wrong. str(s) stays a str."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint(f\"{3.14159:.2f}\")",
    "options": [
      "3.14",
      "3.14159",
      "3.15",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. :.2f formats to 2 decimal places (rounded).",
      "1": "Wrong. Formatting rounds/truncates to 2 decimals.",
      "2": "Wrong. 3.14159 rounds to 3.14, not 3.15.",
      "3": "Wrong. f-strings are valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('hello'.replace('l','L', 1))",
    "options": [
      "heLlo",
      "heLLo",
      "heLLO",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Only the first 'l' is replaced due to count=1.",
      "1": "Wrong. That replaces two l's.",
      "2": "Wrong. That replaces all l's.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('  x  '.strip())",
    "options": [
      "'x'",
      "x",
      "  x  ",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. print doesn't include quotes.",
      "1": "Correct. strip removes surrounding whitespace; print shows x.",
      "2": "Wrong. strip removes whitespace.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'[::-1])",
    "options": [
      "abc",
      "cba",
      "bac",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It reverses.",
      "1": "Correct. Step -1 reverses the string.",
      "2": "Wrong. That's not full reverse.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('x' in 'exam')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Membership test checks substring presence.",
      "1": "Wrong. 'exam' contains 'x'.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Regex",
    "prompt": "Which function returns an iterator of match objects?",
    "options": [
      "re.match",
      "re.search",
      "re.finditer",
      "re.findall"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. match checks only at the start and returns one match or None.",
      "1": "Wrong. search returns one match or None.",
      "2": "Correct. re.finditer returns an iterator of match objects.",
      "3": "Wrong. findall returns strings/tuples, not match objects."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('π'.encode('utf-8'))",
    "options": [
      "'π'",
      "b'\\xcf\\x80'",
      "b'π'",
      "UnicodeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. encode returns bytes, not str.",
      "1": "Correct. UTF-8 encodes π to the byte sequence \\xcf\\x80.",
      "2": "Wrong. bytes display escapes for non-ASCII.",
      "3": "Wrong. UTF-8 can encode π."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a\\nb'.splitlines())",
    "options": [
      "['a\\nb']",
      "['a', 'b']",
      "['a', 'b', '']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It splits into two lines.",
      "1": "Correct. splitlines splits on line boundaries.",
      "2": "Wrong. There is no trailing newline.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a' < 'aa')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Lexicographically, shorter prefix comes first.",
      "1": "Wrong. 'a' is a prefix of 'aa', so it compares smaller.",
      "2": "Wrong. Valid comparison.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('{}'.format(5))",
    "options": [
      "5",
      "'5'",
      "{}",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. format inserts 5 into the placeholder and produces '5', which prints as 5.",
      "1": "Wrong. print doesn't include quotes.",
      "2": "Wrong. Placeholder is replaced.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a,b,c'.partition(','))",
    "options": [
      "('a', ',', 'b,c')",
      "['a', ',', 'b,c']",
      "('a,b,c')",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. partition splits into (head, sep, tail) at first occurrence.",
      "1": "Wrong. It returns a tuple.",
      "2": "Wrong. It splits at the separator.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a,b,c'.rpartition(','))",
    "options": [
      "('a,b', ',', 'c')",
      "('a', ',', 'b,c')",
      "('a,b,c', ',', '')",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. rpartition splits at the last occurrence.",
      "1": "Wrong. That's partition, not rpartition.",
      "2": "Wrong. There's content after the last comma.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('ab' * 0)",
    "options": [
      "ab",
      "",
      "0",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's repeated zero times.",
      "1": "Correct. Repeating zero times yields empty string.",
      "2": "Wrong. It doesn't stringify the multiplier.",
      "3": "Wrong. Valid operation."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'.startswith('a'))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. It starts with 'a'.",
      "1": "Wrong. 'abc' does start with 'a'.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(x, acc=None):\n    if acc is None:\n        acc = []\n    acc.append(x)\n    return acc\n\nprint(f(1))\nprint(f(2))",
    "options": [
      "[1] then [2]",
      "[1] then [1, 2]",
      "[] then [2]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Using None avoids the mutable-default pitfall; each call gets a fresh list.",
      "1": "Wrong. That happens with a mutable default list.",
      "2": "Wrong. First call appends 1.",
      "3": "Wrong. Valid code."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 1\n\ndef f():\n    global x\n    x = 2\n\nf()\nprint(x)",
    "options": [
      "1",
      "2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. global updates x.",
      "1": "Correct. global makes assignment affect the module-level x.",
      "2": "Wrong. No read-before-assign issue.",
      "3": "Wrong. x exists."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\ndef outer():\n    x = 'a'\n    def inner():\n        nonlocal x\n        x = 'b'\n    inner()\n    return x\n\nprint(outer())",
    "options": [
      "a",
      "b",
      "UnboundLocalError",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. inner changes it.",
      "1": "Correct. nonlocal rebinds x in the enclosing scope to 'b'.",
      "2": "Wrong. nonlocal prevents that error.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    int('x')\nexcept ValueError:\n    print('bad')\nelse:\n    print('ok')",
    "options": [
      "bad",
      "ok",
      "bad\\nok",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. int('x') raises ValueError, so except runs and else does not.",
      "1": "Wrong. It fails to parse.",
      "2": "Wrong. else only runs if no exception.",
      "3": "Wrong. ValueError is raised, not TypeError."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    print('try')\nfinally:\n    print('finally')",
    "options": [
      "try",
      "finally",
      "try\\nfinally",
      "No output"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. finally also prints.",
      "1": "Wrong. try also prints.",
      "2": "Correct. finally always runs after the try block.",
      "3": "Wrong. Both print."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    1/0\nexcept ZeroDivisionError:\n    print('z')\nfinally:\n    print('f')",
    "options": [
      "z\\nf",
      "f only",
      "z only",
      "Raises ZeroDivisionError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. except handles it, then finally runs.",
      "1": "Wrong. except prints z too.",
      "2": "Wrong. finally always runs.",
      "3": "Wrong. Exception is handled."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    raise KeyError('k')\nexcept KeyError as e:\n    print(e.args[0])",
    "options": [
      "k",
      "'k'",
      "KeyError",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. args[0] is the string passed to KeyError.",
      "1": "Wrong. Printing args[0] prints k (no quotes).",
      "2": "Wrong. It's handled.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(*args):\n    return len(args)\n\nprint(f(1,2,3))",
    "options": [
      "0",
      "1",
      "3",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. There are args.",
      "1": "Wrong. There are 3.",
      "2": "Correct. *args collects positional arguments into a tuple of length 3.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(**kwargs):\n    return 'x' in kwargs\n\nprint(f(x=1))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. **kwargs collects keyword args into a dict with key 'x'.",
      "1": "Wrong. 'x' is present.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\nprint((lambda x: x+1)(2))",
    "options": [
      "2",
      "3",
      "TypeError",
      "<function ...>"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It adds 1.",
      "1": "Correct. The lambda is called with 2 and returns 3.",
      "2": "Wrong. Valid call.",
      "3": "Wrong. It's invoked, so it prints the result."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(a, b, /, c):\n    return a, b, c\n\nprint(f(1, 2, c=3))",
    "options": [
      "(1, 2, 3)",
      "TypeError",
      "(1, 3, 2)",
      "SyntaxError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. a and b are positional-only; c can be passed by keyword.",
      "1": "Wrong. This call respects positional-only params.",
      "2": "Wrong. Order is (a,b,c).",
      "3": "Wrong. This is valid Python 3.8+ syntax."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What happens?\n\ndef f(a, *, b):\n    return a + b\n\nf(1, 2)",
    "options": [
      "Returns 3",
      "TypeError",
      "SyntaxError",
      "Returns 12"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. b must be keyword.",
      "1": "Correct. b is keyword-only, so passing it positionally raises TypeError.",
      "2": "Wrong. Definition is valid.",
      "3": "Wrong. Not string concatenation."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    {}['x']\nexcept KeyError:\n    print('missing')",
    "options": [
      "missing",
      "KeyError",
      "None",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Accessing a missing dict key raises KeyError, which is caught.",
      "1": "Wrong. It's handled by except.",
      "2": "Wrong. It prints missing.",
      "3": "Wrong. The error is KeyError."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What is printed?\n\ntry:\n    pass\nexcept Exception:\n    print('except')\nelse:\n    print('else')",
    "options": [
      "except",
      "else",
      "except\\nelse",
      "No output"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. except doesn't run without an exception.",
      "1": "Correct. No exception occurs, so else runs.",
      "2": "Wrong. except won't run.",
      "3": "Wrong. else prints."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 1\n\ndef f():\n    return x\n\nx = 2\nprint(f())",
    "options": [
      "1",
      "2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. x was reassigned before calling f.",
      "1": "Correct. f reads the global name x at call time; x is 2 then.",
      "2": "Wrong. No local assignment in f.",
      "3": "Wrong. x exists."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\ndef f():\n    x = 1\n    def g():\n        return x\n    return g\n\nh = f()\nprint(h())",
    "options": [
      "1",
      "NameError",
      "UnboundLocalError",
      "<function ...>"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. g closes over x from f's scope.",
      "1": "Wrong. x is captured in the closure.",
      "2": "Wrong. x is assigned before use.",
      "3": "Wrong. h() calls g and returns 1."
    }
  },
  {
    "topic": "Closures",
    "prompt": "How do you make each lambda capture the loop value (best answer)?\n\nfuncs=[]\nfor i in range(3):\n    funcs.append(lambda: i)",
    "options": [
      "Use lambda i=i: i",
      "Use nonlocal i",
      "Use global i",
      "Use i.copy()"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Default args bind the current value at definition time.",
      "1": "Wrong. nonlocal is for assignment to an enclosing binding.",
      "2": "Wrong. global doesn't create per-iteration bindings.",
      "3": "Wrong. i is an int and has no copy() effect here."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport itertools\nprint(list(itertools.islice(itertools.count(10), 3)))",
    "options": [
      "[10, 11, 12]",
      "[10, 11, 12, 13]",
      "[0, 1, 2]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. count(10) yields 10,11,12,... and islice takes the first 3.",
      "1": "Wrong. islice(..., 3) takes 3 items.",
      "2": "Wrong. It starts from 10.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.chain([1,2],[3]) produce when converted to list?",
    "options": [
      "[1, 2, 3]",
      "[[1,2],[3]]",
      "[1,2,[3]]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. chain concatenates iterables sequentially.",
      "1": "Wrong. It doesn't nest lists.",
      "2": "Wrong. It yields elements, not sublists.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.product([1,2], ['a','b']) produce (as a list)?",
    "options": [
      "[(1,'a'), (1,'b'), (2,'a'), (2,'b')]",
      "[(1,'a'), (2,'b')]",
      "[(1,2), ('a','b')]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. product is the Cartesian product.",
      "1": "Wrong. That's not all pairs.",
      "2": "Wrong. It pairs elements across iterables.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport math\nprint(math.floor(-1.2))",
    "options": [
      "-1",
      "-2",
      "1",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's truncation toward zero.",
      "1": "Correct. floor rounds toward negative infinity; floor(-1.2) is -2.",
      "2": "Wrong. Sign is negative.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(round(2.5))",
    "options": [
      "2",
      "3",
      "2.5",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Python uses bankers rounding: ties go to even, so 2.5 rounds to 2.",
      "1": "Wrong. That would be round-half-up, not Python's default.",
      "2": "Wrong. round returns an int here.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(divmod(7, 3))",
    "options": [
      "(2, 1)",
      "(1, 2)",
      "(7, 3)",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. divmod returns (quotient, remainder).",
      "1": "Wrong. Order is (quotient, remainder).",
      "2": "Wrong. It computes quotient and remainder.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What does list[int] mean (Python 3.9+)?",
    "options": [
      "A list of ints (type hint)",
      "A list literal",
      "Runtime enforcement of int",
      "SyntaxError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. It's a generic type hint meaning list of int.",
      "1": "Wrong. That's [] syntax.",
      "2": "Wrong. Type hints don't enforce at runtime by default.",
      "3": "Wrong. It's valid in 3.9+."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What does this print?\n\nfrom typing import Optional\nx: Optional[int] = None\nprint(x is None)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. x is set to None.",
      "1": "Wrong. x is None.",
      "2": "Wrong. No exception.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "What does this return?\n\nasync def f():\n    return 1\n\nx = f()\nprint(type(x).__name__)",
    "options": [
      "coroutine",
      "int",
      "Task",
      "function"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Calling an async function returns a coroutine object.",
      "1": "Wrong. It doesn't run until awaited.",
      "2": "Wrong. It isn't a Task unless scheduled.",
      "3": "Wrong. It's a coroutine object, not a function."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def __init__(self):\n        self.x = 1\n\na = A()\nprint(hasattr(a, 'x'))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __init__ sets self.x, so attribute exists.",
      "1": "Wrong. x was created.",
      "2": "Wrong. hasattr works here.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def __repr__(self):\n        return 'A()'\n\nprint(A())",
    "options": [
      "<__main__.A object ...>",
      "A()",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __repr__ overrides default repr.",
      "1": "Correct. print uses __str__ or falls back to __repr__.",
      "2": "Wrong. Valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def __iter__(self):\n        return iter([1,2])\n\nprint(list(A()))",
    "options": [
      "[1, 2]",
      "[]",
      "TypeError",
      "[<A ...>]"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __iter__ returns an iterator over [1,2].",
      "1": "Wrong. It yields two items.",
      "2": "Wrong. list() can iterate it.",
      "3": "Wrong. It iterates, not wraps."
    }
  },
  {
    "topic": "Dataclasses",
    "prompt": "What does this print?\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass P:\n    x: int\n\np = P(1)\nprint(p.x)",
    "options": [
      "1",
      "x",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. dataclass generates an __init__ and stores x.",
      "1": "Wrong. It prints the value 1.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport pathlib\np = pathlib.Path('a') / 'b'\nprint(str(p))",
    "options": [
      "a/b",
      "a\\b",
      "('a','b')",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Path joining with / builds a path like a/b (rendered with OS separator when stringified).",
      "1": "Wrong. On Windows it may display backslashes; but in many environments it's 'a/b'.",
      "2": "Wrong. It's a Path, not a tuple.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nfrom collections import Counter\nprint(Counter('aab')['a'])",
    "options": [
      "1",
      "2",
      "3",
      "KeyError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 'a' appears twice.",
      "1": "Correct. Counter counts occurrences; 'a' appears twice.",
      "2": "Wrong. There are only two.",
      "3": "Wrong. Missing keys default to 0, and this key exists."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nfrom collections import defaultdict\n\nd = defaultdict(int)\nprint(d['missing'])",
    "options": [
      "0",
      "None",
      "KeyError",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. defaultdict(int) uses int() -> 0 for missing keys and inserts it.",
      "1": "Wrong. Default is int(), which is 0.",
      "2": "Wrong. defaultdict doesn't raise for missing keys.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport datetime as dt\nprint(type(dt.date.today()).__name__)",
    "options": [
      "datetime",
      "date",
      "time",
      "str"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's dt.datetime.",
      "1": "Correct. dt.date.today() returns a date object.",
      "2": "Wrong. That's dt.time.",
      "3": "Wrong. It's not a string."
    }
  },
  {
    "topic": "Security",
    "prompt": "Which is TRUE about subprocess.run(..., shell=True)?",
    "options": [
      "Always safe",
      "Can be vulnerable to shell injection if inputs are untrusted",
      "Disables command execution",
      "Requires asyncio"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's not always safe.",
      "1": "Correct. shell=True can interpret input via a shell, increasing injection risk with untrusted strings.",
      "2": "Wrong. It still executes commands.",
      "3": "Wrong. asyncio isn't required."
    }
  },
  {
    "topic": "Testing",
    "prompt": "In unittest, what does setUp do?",
    "options": [
      "Runs once per test case class",
      "Runs before each test method",
      "Runs after each test method",
      "Is only for async tests"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's setUpClass.",
      "1": "Correct. setUp runs before each test method.",
      "2": "Wrong. That's tearDown.",
      "3": "Wrong. It's for all tests."
    }
  },
  {
    "topic": "Performance",
    "prompt": "Which is usually faster for membership: x in set vs x in list (large collections)?",
    "options": [
      "List is faster",
      "Set is faster on average",
      "They are always identical",
      "Depends only on OS"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Lists require scanning.",
      "1": "Correct. Set membership is O(1) average; list is O(n).",
      "2": "Wrong. Different algorithms.",
      "3": "Wrong. Not OS-dependent in that way."
    }
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nprint(1e3 == 1000)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. 1e3 is 1000.0, numerically equal to 1000.",
      "1": "Wrong. They compare equal by value.",
      "2": "Wrong. Valid comparison.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nimport decimal\nprint(decimal.Decimal('0.1') + decimal.Decimal('0.2') == decimal.Decimal('0.3'))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Decimal does exact base-10 arithmetic with these literals.",
      "1": "Wrong. With Decimal strings, this is exact.",
      "2": "Wrong. Valid.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Bitwise",
    "prompt": "What does this print?\n\nprint(5 & 3)",
    "options": [
      "1",
      "4",
      "7",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. 5 (101) & 3 (011) = 001 -> 1.",
      "1": "Wrong. That's 5 & 4 style outcome.",
      "2": "Wrong. That's OR (|) result.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Bitwise",
    "prompt": "What does this print?\n\nprint(5 | 2)",
    "options": [
      "7",
      "3",
      "1",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. 5 (101) | 2 (010) = 111 -> 7.",
      "1": "Wrong. That's XOR for 1? no.",
      "2": "Wrong. Not AND.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this print?\n\nprint([x*x for x in range(4) if x%2==0])",
    "options": [
      "[0, 4]",
      "[1, 9]",
      "[0, 1, 4, 9]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Squares of even x in 0..3 are 0 and 4.",
      "1": "Wrong. Those are odd squares.",
      "2": "Wrong. Filter keeps only evens.",
      "3": "Wrong. Valid."
    }
  },
  {
    "topic": "Generators",
    "prompt": "What does this print?\n\ng = (x*x for x in range(3))\nprint(next(g), list(g))",
    "options": [
      "0 [1, 4]",
      "0 [0, 1, 4]",
      "1 [4]",
      "StopIteration"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. next yields 0, then the generator continues with remaining 1 and 4.",
      "1": "Wrong. 0 was already consumed.",
      "2": "Wrong. First next(g) yields 0, not 1.",
      "3": "Wrong. It isn't exhausted after one next."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport json\nprint(json.loads('\"x\"'))",
    "options": [
      "x",
      "'x'",
      "\"x\"",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. json.loads parses the JSON string into the Python str 'x', which prints as x.",
      "1": "Wrong. print doesn't include quotes.",
      "2": "Wrong. That's the JSON literal representation.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport random\nrandom.seed(0)\nprint(isinstance(random.random(), float))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. random.random() returns a float in [0.0, 1.0).",
      "1": "Wrong. It returns float.",
      "2": "Wrong. Valid.",
      "3": "Wrong. Deterministic for type."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def f(self):\n        return 'A'\n\nclass B(A):\n    pass\n\nprint(B().f())",
    "options": [
      "A",
      "B",
      "AB",
      "AttributeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. B inherits f from A unchanged.",
      "1": "Wrong. B doesn't override f.",
      "2": "Wrong. No concatenation occurs.",
      "3": "Wrong. Method exists via inheritance."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2]\ny = x\nx = x + [3]\nprint(y)",
    "options": [
      "[1,2,3]",
      "[1,2]",
      "[3]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y was not updated because x was rebound, not mutated.",
      "1": "Correct. x + [3] creates a new list and rebinds x; y still points to the original [1,2].",
      "2": "Wrong. y references the original list.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "File IO",
    "prompt": "What does this print?\n\nwith open('test.txt', 'w') as f:\n    f.write('hi')\nprint(f.closed)",
    "options": [
      "True",
      "False",
      "Raises ValueError",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Files opened with 'with' are closed automatically after the block.",
      "1": "Wrong. The context manager closes the file.",
      "2": "Wrong. Accessing f.closed is valid.",
      "3": "Wrong. Behavior is deterministic."
    }
  },
  {
    "topic": "Regex",
    "prompt": "What does this return?\n\nimport re\nre.findall(r'\\d+', 'a1b22c333')",
    "options": [
      "['1', '22', '333']",
      "[1, 22, 333]",
      "['a', 'b', 'c']",
      "Raises ValueError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. findall returns all digit substrings as strings.",
      "1": "Wrong. Results are strings, not ints.",
      "2": "Wrong. Regex targets digits.",
      "3": "Wrong. Valid regex usage."
    }
  },
  {
    "topic": "Concurrency",
    "prompt": "Which scenario benefits most from threading in CPython?",
    "options": [
      "CPU-bound numeric computation",
      "Heavy numerical loops",
      "I/O-bound tasks like network requests",
      "Matrix multiplication"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. CPU-bound work is limited by the GIL.",
      "1": "Wrong. Still CPU-bound.",
      "2": "Correct. I/O-bound threads can overlap waiting time.",
      "3": "Wrong. CPU-bound."
    }
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this produce?\n\n[(i, j) for i in range(2) for j in range(2)]",
    "options": [
      "[(0,0), (0,1), (1,0), (1,1)]",
      "[(0,1), (1,0)]",
      "[(0,0), (1,1)]",
      "Raises TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Nested comprehensions expand left to right.",
      "1": "Wrong. Missing pairs.",
      "2": "Wrong. That's diagonal only.",
      "3": "Wrong. Valid comprehension."
    }
  },
  {
    "topic": "Decorators",
    "prompt": "What is the purpose of functools.wraps inside a decorator?",
    "options": [
      "Improve performance",
      "Preserve metadata like __name__ and __doc__",
      "Enable recursion",
      "Make decorators thread-safe"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. wraps is not for performance.",
      "1": "Correct. wraps copies metadata from the wrapped function.",
      "2": "Wrong. Recursion is unrelated.",
      "3": "Wrong. Thread safety is unrelated."
    }
  },
  {
    "topic": "Generators",
    "prompt": "What keyword allows sending a value into a generator?",
    "options": [
      "yield from",
      "send",
      "next",
      "throw"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. yield from delegates iteration.",
      "1": "Correct. send(value) resumes a generator and injects a value.",
      "2": "Wrong. next sends None.",
      "3": "Wrong. throw raises an exception inside the generator."
    }
  },
  {
    "topic": "OOP",
    "prompt": "Which method is called when accessing a missing attribute?",
    "options": [
      "__getattribute__",
      "__getattr__",
      "__missing__",
      "__lookup__"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __getattribute__ runs for all attribute access.",
      "1": "Correct. __getattr__ is called only if attribute is not found.",
      "2": "Wrong. __missing__ is for dict subclasses.",
      "3": "Wrong. Not a Python hook."
    }
  },
  {
    "topic": "Precedence",
    "prompt": "What does this print?\n\nprint(not True or False)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. not True is False; False or False is False.",
      "1": "Correct. not has higher precedence than or.",
      "2": "Wrong. Valid expression.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "Which Python 3 construct is best for efficiently extracting only the even numbers from a large dataset?",
    "options": [
      "zip(dataset, dataset)",
      "map(lambda x: x % 2 == 0, dataset)",
      "functools.reduce(lambda acc, x: acc + ([x] if x % 2 == 0 else []), dataset, [])",
      "[x for x in dataset if x % 2 == 0]",
      "filter(lambda x: x % 2 == 0, dataset)"
    ],
    "correct": [
      4
    ],
    "explanations": {
      "0": "Wrong. zip pairs iterables; it doesn't filter values.",
      "1": "Wrong. map transforms each element; it would produce booleans, not the even numbers.",
      "2": "Wrong. This is unnecessarily complex and inefficient for filtering.",
      "3": "Close, and it works, but the question asks which construct is best/most direct for filtering; filter is the dedicated tool here.",
      "4": "Correct. filter selects elements that satisfy the predicate (even numbers)."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "You have a dict user_settings. Which Python 3 approaches remove the key \"language\" without raising an exception if the key is missing?",
    "options": [
      "user_settings.remove(\"language\")",
      "if \"language\" in user_settings:\n    del user_settings[\"language\"]",
      "del user_settings[\"language\"]",
      "user_settings.pop(\"language\", None)",
      "user_settings.get(\"language\", None)"
    ],
    "correct": [
      1,
      3
    ],
    "explanations": {
      "0": "Wrong. dict has no remove() method.",
      "1": "Correct. Checks existence before deleting.",
      "2": "Wrong. Raises KeyError if the key is missing.",
      "3": "Correct. pop with a default avoids KeyError and removes the key if present.",
      "4": "Wrong. get retrieves a value; it does not remove the key."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "Why might a Python developer choose a tuple over a list for immutable configuration data?",
    "options": [
      "Tuples typically consume less memory than lists.",
      "Tuples prevent unintended mutation of configuration values.",
      "Tuples can be slightly faster to iterate than lists.",
      "Lists support fixed schema definitions better than tuples.",
      "Lists provide faster write performance than tuples."
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanations": {
      "0": "Correct. Tuples are generally more memory-efficient than lists for the same contents.",
      "1": "Correct. Tuples are immutable, so you can't accidentally reassign elements.",
      "2": "Correct. Iteration over tuples can be marginally faster in CPython.",
      "3": "Wrong. Both can represent fixed schemas; tuples are often used for fixed records, not lists.",
      "4": "Wrong. Write performance isn't a reason to prefer tuples for immutable config."
    }
  },
  {
    "topic": "Iterators",
    "prompt": "Given:\n\ndef chain(*iterables):\n    for it in iterables:\n        yield from it\n\nWhat does list(chain(\"AB\", \"CD\")) produce?",
    "options": [
      "[['A', 'B'], ['C', 'D']]",
      "['A', 'C', 'B', 'D']",
      "['AB', 'CD']",
      "['A', 'B', 'C', 'D']",
      "[65, 66, 67, 68]"
    ],
    "correct": [
      3
    ],
    "explanations": {
      "0": "Wrong. The generator yields individual characters, not sublists.",
      "1": "Wrong. chain yields all of the first iterable, then all of the second (not interleaved).",
      "2": "Wrong. It doesn't yield the original strings; it yields from them character-by-character.",
      "3": "Correct. Strings are iterable, so yield from produces each character in order.",
      "4": "Wrong. You'd only see code points like that if you applied ord()."
    }
  },
  {
    "topic": "Comprehensions",
    "prompt": "In Python 3, which of the following creates a generator comprehension (generator expression)?",
    "options": [
      "[x**2 for x in range(5)]",
      "{x: x**2 for x in range(5)}",
      "(x**2 for x in range(5))",
      "list(x**2 for x in range(5))",
      "{x**2 for x in range(5)}"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Square brackets create a list comprehension.",
      "1": "Wrong. Curly braces with key:value create a dict comprehension.",
      "2": "Correct. Parentheses around a comprehension create a generator expression.",
      "3": "Wrong. This evaluates a generator expression into a list.",
      "4": "Wrong. Curly braces without key:value create a set comprehension."
    }
  },
  {
    "topic": "Strings",
    "prompt": "Given:\n\nsentence = \"data science with python\"\nprint(sentence.title())\n\nWhich output is correct?",
    "options": [
      "\"Data Science With Python\"",
      "\"Data science with python\"",
      "\"DATA SCIENCE WITH PYTHON\"",
      "\"Data Science with Python\"",
      "\"Datasciencewithpython\""
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. .title() capitalizes the first letter of each word.",
      "1": "Wrong. That's the original sentence (lowercase).",
      "2": "Wrong. That's .upper() behavior.",
      "3": "Wrong. .title() also capitalizes \"With\" in the middle.",
      "4": "Wrong. .title() does not remove spaces."
    }
  },
  {
    "topic": "Operators",
    "prompt": "A developer wrote:\n\ndiscount = 100 - 20 * 0.1\n\nThey expected a different result due to grouping. Which change fixes the operator-precedence grouping issue?",
    "options": [
      "(100 - 20) * 0.1",
      "(100 - 20) / 0.1",
      "100 - 20 / 0.1",
      "100 / (20 * 0.1)",
      "100 - (20 * 0.1)"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Parentheses force subtraction first, then multiplication.",
      "1": "Wrong. This changes the operation to division and produces a very different value.",
      "2": "Wrong. This changes the grouping and produces a different (also likely unintended) value.",
      "3": "Wrong. This computes a ratio, not a discounted amount.",
      "4": "Wrong. This is equivalent to the original expression (multiplication already happens before subtraction)."
    }
  },
  {
    "topic": "Control Flow",
    "prompt": "Consider:\n\nfor item in shipments:\n    if not item[\"barcode\"]:\n        log_warning(\"Unreadable barcode\")\n        continue\n    if item[\"barcode\"].startswith(\"CRIT\") and item[\"timestamp\"] > item[\"deadline\"]:\n        halt_batch()\n        break\n    process_item(item)\nelse:\n    finalize_batch()\n\nUnder which condition will finalize_batch() execute in Python 3?",
    "options": [
      "Only when no items are processed.",
      "If halt_batch() is called.",
      "All barcodes must be valid and critical items are on time.",
      "The first item must be non-critical.",
      "At least one item must fail the timestamp check."
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. The for-else runs based on whether the loop breaks, not on whether items were processed.",
      "1": "Wrong. If halt_batch() is called, the loop breaks and the else does not run.",
      "2": "Correct. The else runs only if the loop completes without hitting break (i.e., no late critical shipment).",
      "3": "Wrong. The first item doesn't determine whether the loop breaks overall.",
      "4": "Wrong. Failing the timestamp check for a CRIT item triggers break, which prevents the else."
    }
  },
  {
    "topic": "Math",
    "prompt": "A data analyst wrote:\n\nweights = [0.2, 0.3, 0.5]\nscores  = [80, 90, 100]\nprint(sum(w * s for w, s in zip(weights, scores)) / len(scores))\n\nWhy does this produce the wrong weighted result?",
    "options": [
      "The average is divided by len(scores) when a weighted sum should not be averaged that way.",
      "Python 3 evaluates multiplication before addition.",
      "Parentheses around multiplication are required.",
      "Division has higher precedence than multiplication.",
      "sum() has lower precedence than division."
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. With weights summing to 1, the weighted result is sum(w*s). Dividing by len(scores) shrinks it incorrectly.",
      "1": "Wrong. Multiplication-before-addition is correct and not the problem here.",
      "2": "Wrong. The multiplication is already grouped correctly inside the generator expression.",
      "3": "Wrong. Multiplication and division have the same precedence and associate left-to-right; precedence isn't the issue.",
      "4": "Wrong. sum(...) is a function call; the issue is the chosen denominator, not precedence."
    }
  },
  {
    "topic": "Dictionaries",
    "prompt": "You track HTTP status code counts in a dict error_counts.\nRequirements:\n- Increment count if the code exists\n- Initialize to 1 if first seen\n- Avoid exceptions if key is missing\n\nWhich snippets meet these requirements using only standard Python?",
    "options": [
      "if error_counts[code]:\n    error_counts[code] += 1\nelse:\n    error_counts[code] = 1",
      "error_counts[code] = error_counts.pop(code, 0) + 1",
      "error_counts.setdefault(code, 0)\nerror_counts[code] += 1",
      "error_counts[code] = 1 if code not in error_counts else error_counts[code] + 1",
      "error_counts[code] += 1 if code in error_counts else 1"
    ],
    "correct": [
      1,
      2,
      3
    ],
    "explanations": {
      "0": "Wrong. error_counts[code] raises KeyError if code is not present.",
      "1": "Correct. pop with a default avoids KeyError, then assigns incremented value back.",
      "2": "Correct. setdefault ensures the key exists with 0, then increments.",
      "3": "Correct. Explicit membership check avoids KeyError and sets to 1 on first occurrence.",
      "4": "Wrong. The else branch produces 1 but does not assign it back to error_counts[code]."
    }
  },
  {
    "topic": "Concurrency",
    "prompt": "Which statement correctly describes the Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "It prevents all threads from executing any Python code.",
      "It locks files to avoid race conditions.",
      "It prevents processes from sharing memory.",
      "It ensures that only one thread executes Python bytecode at a time.",
      "It is automatically disabled in Python 3."
    ],
    "correct": [
      3
    ],
    "explanations": {
      "0": "Wrong. Threads can run, but they contend for the GIL when executing bytecode.",
      "1": "Wrong. The GIL is not a file lock.",
      "2": "Wrong. Processes are separate OS processes; the GIL is about threads within a process.",
      "3": "Correct. In CPython, the GIL allows only one thread to execute Python bytecode at once.",
      "4": "Wrong. The GIL still exists in CPython in Python 3."
    }
  },
  {
    "topic": "Formatting",
    "prompt": "A report must align currency values to two decimal places. Which Python 3 format option should be used?",
    "options": [
      "\"%.02s\" % value",
      "repr(value)",
      "\"${:.02s}\".format(value)",
      "f\"${value:.2f}\"",
      "str(value)"
    ],
    "correct": [
      3
    ],
    "explanations": {
      "0": "Wrong. %s formats as a string and .02 is width, not decimal precision for numbers.",
      "1": "Wrong. repr() is for debugging representations, not currency formatting.",
      "2": "Wrong. .02s is string precision, not numeric decimal places.",
      "3": "Correct. .2f formats a float to two decimal places (fixed-point).",
      "4": "Wrong. str() does not guarantee two decimal places."
    }
  },
  {
    "topic": "OOP",
    "prompt": "Given:\n\nclass Vehicle:\n    def move(self): return \"Moving\"\n\nclass Flyable:\n    def move(self): return \"Flying\"\n\nclass Drone(Vehicle, Flyable):\n    pass\n\nprint(Drone().move())\n\nWhat is printed?",
    "options": [
      "Depends on the runtime inputs.",
      "Moving",
      "Error: Conflict",
      "None",
      "Flying"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Method resolution order (MRO) is deterministic.",
      "1": "Correct. Drone uses Vehicle first in the base class list, so Vehicle.move is chosen.",
      "2": "Wrong. This is valid; MRO resolves the method.",
      "3": "Wrong. move returns a string, not None.",
      "4": "Wrong. Flyable.move would be used only if Vehicle didn't define move (or ordering changed)."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "user_input = \"45x\"\n\nWhich approaches correctly handle invalid input when converting to int?",
    "options": [
      "balance = 0",
      "try:\n    balance = int(user_input)\nexcept TypeError:\n    balance = 0",
      "balance = int(user_input) if user_input.isdigit() else 0",
      "try:\n    balance = int(user_input)\nexcept ValueError:\n    balance = 0",
      "balance = int(user_input)"
    ],
    "correct": [
      2,
      3
    ],
    "explanations": {
      "0": "Wrong. This doesn't attempt conversion; it just assigns 0.",
      "1": "Wrong. int(\"45x\") raises ValueError, not TypeError.",
      "2": "Correct. isdigit() guards the conversion (\"45x\" is not digits).",
      "3": "Correct. Catching ValueError handles invalid numeric strings.",
      "4": "Wrong. This raises ValueError for \"45x\"."
    }
  },
  {
    "topic": "Functional Programming",
    "prompt": "A retail company stores product sales as a list of numbers. Which use of functools.reduce correctly computes the total (sum)?",
    "options": [
      "reduce(sales, lambda a, b: a + b)",
      "reduce(lambda x: sum(x), sales)",
      "reduce(lambda a, b: a + b, sales)",
      "reduce(sum, sales)",
      "reduce(lambda a, b: a * b, sales)"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. reduce expects the function first, then the iterable.",
      "1": "Wrong. The reducer function must take two arguments (accumulator, next).",
      "2": "Correct. This reduces by repeatedly adding elements.",
      "3": "Wrong. sum() expects an iterable; reduce passes two scalars.",
      "4": "Wrong. This multiplies values (product), not sum."
    }
  },
  {
    "topic": "OOP",
    "prompt": "A BankAccount class must provide an audit method that does not depend on instance-level data but logically belongs to the class. Which techniques support this goal in Python 3?",
    "options": [
      "Use a lambda function assigned to the class.",
      "Define audit_transaction as a regular method using self.",
      "Define audit_transaction as a static method.",
      "Define audit_transaction as a class method using @classmethod.",
      "Define audit_transaction as a private method with __audit_transaction."
    ],
    "correct": [
      2,
      3
    ],
    "explanations": {
      "0": "Wrong. You can do it, but it's not the intended/idiomatic approach for a class-level API.",
      "1": "Wrong. self implies instance-level behavior/state.",
      "2": "Correct. @staticmethod attaches behavior to the class without needing self/cls.",
      "3": "Correct. @classmethod receives cls, which is useful for class-wide behavior or alternate constructors.",
      "4": "Wrong. Name-mangling changes accessibility, not instance vs class dependence."
    }
  },
  {
    "topic": "Files & JSON",
    "prompt": "A Python 3 API logging system writes event data to JSON using UTF-8. Which statement correctly opens the file to work with json.dump() and avoid cross-platform encoding issues?",
    "options": [
      "import json\nwith open(\"log.json\", \"a\", encoding=\"utf-16\") as f:\n    json.dump(data, f)",
      "with open(\"log.json\", \"w\", encoding=\"utf-8\") as f:\n    f.write(json.dumps(data))",
      "import json\nwith open(\"log.json\", \"w\", encoding=\"utf-8\") as f:\n    json.dump(data, f, ensure_ascii=False)",
      "import json\nwith open(\"log.json\", \"w\") as f:\n    json.dump(data, f)",
      "with open(\"log.json\", \"wb\") as f:\n    json.dump(data, f)"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. UTF-16 is not the requested encoding and can cause compatibility issues.",
      "1": "Not ideal. It uses json.dumps + write; it can work, but the requirement calls for json.dump() usage.",
      "2": "Correct. Explicit UTF-8 plus json.dump() (and ensure_ascii=False to preserve Unicode) meets the requirement.",
      "3": "Risky. Omitting encoding uses a platform default that may not be UTF-8.",
      "4": "Wrong. json.dump writes text; the file is opened in binary mode."
    }
  },
  {
    "topic": "Regex",
    "prompt": "You need to match ticket references like INC-1234 or REQ-4567 while excluding malformed entries like REQ123 or INC--0001. Which regex works?",
    "options": [
      "r\"(INC|REQ)\\d+\"",
      "r\"[A-Z]{3,}-\\d+\"",
      "r\"(INC|REQ)-\\d+\"",
      "r\"INC|REQ-\\d+\"",
      "r\"(INC|REQ)-\\d{4}\""
    ],
    "correct": [
      4
    ],
    "explanations": {
      "0": "Wrong. Missing the required hyphen.",
      "1": "Too broad. It matches many 3+ letter prefixes, not just INC/REQ.",
      "2": "Works for INC/REQ with a hyphen and digits of any length, but the examples specify a 4-digit ID.",
      "3": "Wrong. Due to precedence, it matches 'INC' anywhere or 'REQ-<digits>'.",
      "4": "Correct. Requires INC or REQ, a single hyphen, and exactly 4 digits."
    }
  },
  {
    "topic": "Control Flow",
    "prompt": "An HR tool should stop scanning candidates once a fully qualified candidate is found, but continue is used instead of break:\n\nfor c in candidates:\n    if c[\"degree\"] == \"PhD\" and c[\"experience\"] > 5:\n        continue\n    print(f\"Evaluating {c['name']}\")\n\nWhat problems can this cause?",
    "options": [
      "Breaks after evaluating the first candidate.",
      "Enters an infinite loop due to continue.",
      "Raises an exception when iterating over candidates.",
      "Evaluates all candidates regardless of credentials.",
      "Skips evaluation of PhD candidates even when qualified."
    ],
    "correct": [
      3,
      4
    ],
    "explanations": {
      "0": "Wrong. There is no break at all.",
      "1": "Wrong. continue does not create an infinite loop in a for-loop.",
      "2": "Wrong. The code shown iterates normally.",
      "3": "Correct. Without break, the loop continues scanning everyone.",
      "4": "Correct. The qualified PhD candidate is skipped instead of triggering a stop."
    }
  },
  {
    "topic": "Imports",
    "prompt": "A service dynamically imports regional settings:\n\nimport importlib\n\ndef load_settings(region_code):\n    return importlib.import_module(f\"settings.{region_code}\")\n\nA typo renamed settings.us.py to setting.us.py, causing ModuleNotFoundError. What must be done to resolve it?",
    "options": [
      "Rename the file to match the expected fully qualified module path structure.",
      "Ensure the settings modules are listed in sys.modules prior to import.",
      "Refactor the service to use hardcoded if-else imports for each region.",
      "Rebuild the Python interpreter cache using py_compile.",
      "Add the missing module path to the system PATH environment variable."
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. The module name must match the package/module path expected by importlib.import_module.",
      "1": "Wrong. sys.modules is populated after imports; you don't pre-populate it to fix missing files.",
      "2": "Unnecessary. Dynamic import is fine; the issue is the filename/module name mismatch.",
      "3": "Wrong. Bytecode cache is not the cause of ModuleNotFoundError here.",
      "4": "Wrong. Python import paths are controlled by sys.path/PYTHONPATH, not the OS PATH for executables."
    }
  },
  {
    "topic": "Async",
    "prompt": "Why might a coroutine using async for be chosen over a plain generator in a high-throughput pipeline?",
    "options": [
      "Coroutines automatically parallelize CPU-bound code.",
      "Generators cannot handle exceptions.",
      "Coroutines can yield values without memory allocation.",
      "Coroutines store all results in memory before returning.",
      "Coroutines allow non-blocking I/O, improving throughput."
    ],
    "correct": [
      4
    ],
    "explanations": {
      "0": "Wrong. async/await improves I/O concurrency, not CPU parallelism.",
      "1": "Wrong. Generators can handle exceptions (throw, try/except inside).",
      "2": "Wrong. Both generators and async generators stream values; memory allocation is not the key distinction.",
      "3": "Wrong. Coroutines/async generators can stream results; they do not inherently store all results.",
      "4": "Correct. async for works with async iterators, enabling non-blocking I/O and better throughput."
    }
  },
  {
    "topic": "Encapsulation",
    "prompt": "A bank wants every update to an account balance to be validated (must stay ≥ 0) and logged. Which snippet fits this requirement best?",
    "options": [
      "def log_balance(self, val): self.__balance = val",
      "self.balance = abs(value)",
      "balance = property(lambda self: self.__balance)",
      "@property\ndef balance(self):\n    return self.__balance\n\n@balance.setter\ndef balance(self, value):\n    if value < 0:\n        raise ValueError(\"Insufficient funds\")\n    print(f\"Balance updated to {value}\")\n    self.__balance = value",
      "def set_balance(self, value):\n    self.__balance = value\n    print(\"Updated\")"
    ],
    "correct": [
      3
    ],
    "explanations": {
      "0": "Wrong. No validation or logging beyond assignment.",
      "1": "Wrong. It forces non-negative values but doesn't validate business rules or log consistently.",
      "2": "Wrong. Read-only property; it doesn't control updates/validation.",
      "3": "Correct. The setter validates and logs every update before assigning.",
      "4": "Wrong. Logs but does not validate the value."
    }
  },
  {
    "topic": "Strings",
    "prompt": "records = [\" Luffy , 30 \", \"Ace,20\", \" Sabo , 22 \"]\n\nDesired result: [\"Luffy,30\", \"Ace,20\", \"Sabo,22\"]. Which comprehension achieves this?",
    "options": [
      "[r.rstrip() for r in records]",
      "[r.strip() for r in records]",
      "[\",\".join(p.strip() for p in r.split(\",\")) for r in records]",
      "[r.lstrip() for r in records]",
      "[r.replace(\" \", \"\") for r in records]"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. rstrip removes only trailing whitespace; leading/internal whitespace remains.",
      "1": "Wrong. strip removes outer whitespace but keeps spaces around the comma inside the string.",
      "2": "Correct. Split on commas, strip each field, then re-join with commas.",
      "3": "Wrong. lstrip removes only leading whitespace.",
      "4": "Too aggressive. It removes all spaces, including spaces that might be meaningful in names/fields."
    }
  },
  {
    "topic": "Functions as Objects",
    "prompt": "A platform wants to compute final grades using interchangeable strategies (average, weighted, drop-lowest). Which patterns enable passing strategy functions as first-class objects?",
    "options": [
      "def calculate(*args, **kwargs):\n    return sum(args)",
      "def calculate(scores):\n    return strategy(scores)",
      "def calculate(scores, strategy):\n    return strategy(scores)",
      "def calculate(scores: list, strategy: callable) -> float:\n    return strategy(scores)",
      "strategy = lambda scores: sum(scores) / len(scores)\ncalculate([85, 90, 95], strategy)"
    ],
    "correct": [
      2,
      3,
      4
    ],
    "explanations": {
      "0": "Wrong. This doesn't accept a strategy function parameter.",
      "1": "Wrong. strategy is not passed in; it's an undeclared free variable in this snippet.",
      "2": "Correct. Accepts a function argument and calls it.",
      "3": "Correct. Same idea, with type hints indicating a callable strategy.",
      "4": "Correct. Demonstrates assigning a function (lambda) to a variable and passing it to calculate()."
    }
  },
  {
    "topic": "Comprehensions",
    "prompt": "rows = [\"name,age\", \"Luffy,19\", \"Ace,20\"]\n\nWhich comprehension builds a list of dicts like [{\"name\":\"Luffy\",\"age\":\"19\"}, {\"name\":\"Ace\",\"age\":\"20\"}]?",
    "options": [
      "{dict(zip(rows[0], row)) for row in rows[1:]}",
      "[zip(rows[0].split(\",\"), row.split(\",\")) for row in rows[1:]]",
      "[dict((rows[0].split(\",\"), row.split(\",\"))) for row in rows[1:]]",
      "dict(zip(rows[0].split(\",\"), row.split(\",\")))",
      "[dict(zip(rows[0].split(\",\"), row.split(\",\"))) for row in rows[1:]]"
    ],
    "correct": [
      4
    ],
    "explanations": {
      "0": "Wrong. Uses a set comprehension and zips characters from the header string (not split fields).",
      "1": "Wrong. Produces zip objects (iterators), not dicts.",
      "2": "Wrong. dict() expects an iterable of key/value pairs; passing two lists as one tuple is invalid.",
      "3": "Wrong. Not a comprehension, and 'row' is undefined.",
      "4": "Correct. Splits header into keys and each row into values, zips them, and converts to dict for each row."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "archived_doc = ([341, 342, 343], \"sealed\")\n\nA tuple stores a mutable list of page IDs plus an immutable status string. Which statements are correct?",
    "options": [
      "The tuple structure prevents any changes, including changes to its internal list.",
      "Tuples containing mutable types like lists are invalid and should be avoided.",
      "Updating any element of the tuple (e.g., replacing the list or the status) requires creating a new tuple.",
      "Attempting to modify the list of page IDs raises a TypeError because it is part of a tuple.",
      "The list of page IDs can be modified in-place even though it resides within an immutable tuple."
    ],
    "correct": [
      2,
      4
    ],
    "explanations": {
      "0": "Wrong. The tuple is immutable, but it can contain mutable objects that can be changed in-place.",
      "1": "Wrong. This is allowed; you just need to understand the mutability implications.",
      "2": "Correct. You can't rebind tuple slots; to replace an element you must make a new tuple.",
      "3": "Wrong. Modifying the list itself is allowed; only rebinding the tuple element is disallowed.",
      "4": "Correct. The inner list is mutable and can be changed in-place."
    }
  }
]