[
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(type(3/2))",
    "options": [
      "<class 'int'>",
      "<class 'float'>",
      "<class 'decimal.Decimal'>",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. / always returns a float in Python 3.",
      "1": "Correct. 3/2 evaluates to 1.5 (float).",
      "2": "Wrong. Decimal is only used if explicitly created.",
      "3": "Wrong. No exception is raised."
    }
  },
  {
    "topic": "Basics",
    "prompt": "Which statement about '==' and 'is' is TRUE?",
    "options": [
      "'is' compares values",
      "'==' compares identity",
      "'==' compares values; 'is' compares identity",
      "They are interchangeable"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. 'is' checks identity (same object).",
      "1": "Wrong. '==' checks value equality.",
      "2": "Correct. Value vs identity is the key distinction.",
      "3": "Wrong. They are not interchangeable."
    }
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nprint(0.1 + 0.2 == 0.3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on OS"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Floating-point rounding prevents exact equality here.",
      "1": "Correct. 0.1+0.2 is not exactly 0.3 in binary floating point.",
      "2": "Wrong. No exception is raised.",
      "3": "Wrong. This behavior is consistent across platforms."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "Which values are falsy in Python? (Select ALL that apply)",
    "options": [
      "0",
      "''",
      "[]",
      "'0'"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanations": {
      "0": "Correct. Numeric zero is falsy.",
      "1": "Correct. Empty string is falsy.",
      "2": "Correct. Empty list is falsy.",
      "3": "Wrong. Non-empty strings are truthy even if they look like zero."
    }
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint(bool([0]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Any non-empty list is truthy.",
      "1": "Wrong. The list is not empty.",
      "2": "Wrong. bool(list) is valid.",
      "3": "Wrong. bool returns True/False."
    }
  },
  {
    "topic": "Data Structures",
    "prompt": "Which are valid dictionary keys? (Select ALL that apply)",
    "options": [
      "('a', 1)",
      "['a', 1]",
      "{'a': 1}",
      "42"
    ],
    "correct": [
      0,
      3
    ],
    "explanations": {
      "0": "Correct. Tuples are hashable if elements are hashable.",
      "1": "Wrong. Lists are mutable → unhashable.",
      "2": "Wrong. Dicts are mutable → unhashable.",
      "3": "Correct. Integers are hashable."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2,3]\ny = x\nx.append(4)\nprint(y)",
    "options": [
      "[1,2,3]",
      "[1,2,3,4]",
      "[4]",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y references the same list as x.",
      "1": "Correct. Both variables point to the same list object.",
      "2": "Wrong. append mutates the list; it doesn’t replace it with [4].",
      "3": "Wrong. No variable is missing."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2,3]\ny = x[:]\nx.append(4)\nprint(y)",
    "options": [
      "[1,2,3,4]",
      "[1,2,3]",
      "[]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y is a copy; it doesn't see x's append.",
      "1": "Correct. Slicing creates a shallow copy of the list.",
      "2": "Wrong. The copy contains elements.",
      "3": "Wrong. This is valid Python."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = (1)\nprint(type(x))",
    "options": [
      "<class 'tuple'>",
      "<class 'int'>",
      "<class 'list'>",
      "<class 'float'>"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Parentheses alone do not make a tuple.",
      "1": "Correct. (1) is just the integer 1.",
      "2": "Wrong. Lists use square brackets.",
      "3": "Wrong. No float conversion occurs."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = (1,)\nprint(type(x))",
    "options": [
      "<class 'tuple'>",
      "<class 'int'>",
      "<class 'list'>",
      "<class 'float'>"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. The trailing comma makes it a tuple.",
      "1": "Wrong. (1,) is not an int.",
      "2": "Wrong. Not a list.",
      "3": "Wrong. Not a float."
    }
  },
  {
    "topic": "Generators",
    "prompt": "Which create a generator? (Select ALL that apply)",
    "options": [
      "(x for x in range(3))",
      "[x for x in range(3)]",
      "def f():\n    yield 1",
      "{x for x in range(3)}"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. Generator expression.",
      "1": "Wrong. List comprehension creates a list.",
      "2": "Correct. 'yield' makes a generator function.",
      "3": "Wrong. Set comprehension creates a set."
    }
  },
  {
    "topic": "Generators",
    "prompt": "What happens when a generator is exhausted?",
    "options": [
      "Returns None",
      "Restarts automatically",
      "Raises StopIteration",
      "Loops forever"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. It doesn’t return None to signal end.",
      "1": "Wrong. Generators do not restart on their own.",
      "2": "Correct. Iteration ends via StopIteration.",
      "3": "Wrong. It terminates."
    }
  },
  {
    "topic": "Sets",
    "prompt": "What is the result of: len({1,2,2,3})",
    "options": [
      "4",
      "3",
      "2",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Duplicates are removed.",
      "1": "Correct. The set is {1,2,3}.",
      "2": "Wrong. There are three unique elements.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Pitfalls",
    "prompt": "What does this print?\n\nprint([[]] * 2)",
    "options": [
      "[[], []] independent lists",
      "[[]] twice",
      "Two references to the same inner list",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. The inner list is shared (same object repeated).",
      "1": "Wrong. It becomes a list of length 2, not a nested repetition conceptually.",
      "2": "Correct. List multiplication repeats references to the same object.",
      "3": "Wrong. No error."
    }
  },
  {
    "topic": "Functions",
    "prompt": "Which statement about default arguments is TRUE?",
    "options": [
      "Evaluated at call time",
      "Evaluated once at function definition",
      "Reset every call",
      "Must be immutable"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Defaults are evaluated when the def runs (definition time).",
      "1": "Correct. This is why mutable defaults can be dangerous.",
      "2": "Wrong. They persist across calls.",
      "3": "Wrong. They can be mutable; it’s just often a pitfall."
    }
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(x, acc=[]):\n    acc.append(x)\n    return acc\n\nprint(f(1))\nprint(f(2))",
    "options": [
      "[1] then [2]",
      "[1] then [1, 2]",
      "[1] then [1]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. acc is the same list each call.",
      "1": "Correct. The default list is reused and grows.",
      "2": "Wrong. It doesn’t reset automatically.",
      "3": "Wrong. Valid code."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 10\n\ndef g():\n    x = 5\n\ng()\nprint(x)",
    "options": [
      "5",
      "10",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Local assignment does not affect global x.",
      "1": "Correct. The global x stays 10.",
      "2": "Wrong. No read-before-assign occurs here.",
      "3": "Wrong. x exists globally."
    }
  },
  {
    "topic": "Scope",
    "prompt": "What happens?\n\nx = 1\n\ndef h():\n    print(x)\n    x = 2\n\nh()",
    "options": [
      "Prints 1",
      "Prints 2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python treats x as local due to assignment in the function.",
      "1": "Wrong. It fails before printing.",
      "2": "Correct. Local variable referenced before assignment.",
      "3": "Wrong. Name exists, but scope rules make it local."
    }
  },
  {
    "topic": "Scope",
    "prompt": "Which keyword allows assigning to a variable in an enclosing (non-global) scope?",
    "options": [
      "global",
      "nonlocal",
      "outer",
      "static"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. global targets module scope, not enclosing function scope.",
      "1": "Correct. nonlocal targets nearest enclosing function scope.",
      "2": "Wrong. Not a Python keyword.",
      "3": "Wrong. Not a Python keyword."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a' < 'B')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on locale"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Unicode code points put 'B' before 'a'.",
      "1": "Correct. 'B' has a smaller code point than 'a'.",
      "2": "Wrong. String comparisons are valid.",
      "3": "Wrong. Python uses Unicode code points, not locale."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What is the output?\n\nprint(','.join(['a', 'b', 'c']))",
    "options": [
      "a b c",
      "a,b,c",
      "['a','b','c']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. join uses the separator exactly (comma here).",
      "1": "Correct. Comma-separated string.",
      "2": "Wrong. That would be repr of a list, not join output.",
      "3": "Wrong. join works with strings."
    }
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "Which converts bytes to str using UTF-8?",
    "options": [
      "b.encode('utf-8')",
      "b.decode('utf-8')",
      "str(b)",
      "bytes(b)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. encode converts str -> bytes.",
      "1": "Correct. decode converts bytes -> str.",
      "2": "Wrong. str(b) produces a representation like \"b'...'\".",
      "3": "Wrong. bytes(b) expects an int iterable or buffer; not decoding."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('hello'[:3])",
    "options": [
      "hel",
      "ell",
      "llo",
      "IndexError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Slice from start up to index 3 (exclusive).",
      "1": "Wrong. That would be 'hello'[1:4].",
      "2": "Wrong. That would be 'hello'[2:5].",
      "3": "Wrong. Slicing is safe; no IndexError."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "Which statement about slicing is TRUE? (Select ALL that apply)",
    "options": [
      "Slicing a list returns a new list",
      "Slicing deep-copies nested objects",
      "Slicing supports a step value",
      "Slicing always returns a view"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. It creates a new list object (shallow copy).",
      "1": "Wrong. It’s a shallow copy; nested objects are shared.",
      "2": "Correct. list[start:stop:step] supports step.",
      "3": "Wrong. Python list slicing is not a view (unlike some libraries)."
    }
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = [1,2,3]\nx[1:2] = [9,9]\nprint(x)",
    "options": [
      "[1, 9, 3]",
      "[1, 9, 9, 3]",
      "[9, 9]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Replacing a slice can change length; here it inserts two items.",
      "1": "Correct. The slice [2] is replaced by [9,9].",
      "2": "Wrong. That would replace the whole list.",
      "3": "Wrong. Slice assignment is valid."
    }
  },
  {
    "topic": "Sorting",
    "prompt": "What does this print?\n\nprint(sorted(['10','2','1']))",
    "options": [
      "['1','2','10']",
      "['10','1','2']",
      "['10','2','1']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That would be numeric sort, but these are strings.",
      "1": "Correct. Lexicographic string order: '10' < '1' < '2' is false; actual is '10','1','2'.",
      "2": "Wrong. That’s the original order, not sorted.",
      "3": "Wrong. Sorting strings is valid."
    }
  },
  {
    "topic": "Sorting",
    "prompt": "How do you sort numbers by absolute value?",
    "options": [
      "sorted(nums, key=abs)",
      "sorted(abs(nums))",
      "nums.sort(abs)",
      "sort(nums, abs)"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. key=abs sorts by absolute value.",
      "1": "Wrong. abs(nums) is invalid for a list.",
      "2": "Wrong. list.sort takes keyword key=..., not a positional function like that.",
      "3": "Wrong. sort(...) is not a built-in function in that form."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does enumerate(iterable) produce?",
    "options": [
      "Only items",
      "Only indexes",
      "Pairs of (index, item)",
      "Triples of (index, item, length)"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. It includes indexes too.",
      "1": "Wrong. It includes items too.",
      "2": "Correct. enumerate yields (index, value) pairs.",
      "3": "Wrong. No length is included."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What is printed?\n\nprint(list(zip([1,2,3], ['a','b'])))",
    "options": [
      "[(1,'a'), (2,'b')]",
      "[(1,'a'), (2,'b'), (3,None)]",
      "TypeError",
      "[(1,'a'), (2,'b'), (3,'c')]"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. zip stops at the shortest iterable.",
      "1": "Wrong. zip does not pad with None by default.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. 'c' is not present."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "What does dict.get('k', 99) return if 'k' is missing?",
    "options": [
      "Raises KeyError",
      "Returns None always",
      "Returns 99",
      "Adds 'k' with 99"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. get does not raise KeyError.",
      "1": "Wrong. It returns default if provided.",
      "2": "Correct. Default is returned when key is missing.",
      "3": "Wrong. get does not mutate the dict."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "What does this print?\n\nd = {'a': 1}\nprint(d.setdefault('b', 2), d)",
    "options": [
      "2 {'a': 1, 'b': 2}",
      "None {'a': 1}",
      "KeyError",
      "2 {'a': 1}"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. setdefault inserts missing key and returns the value.",
      "1": "Wrong. It will insert 'b' and return 2.",
      "2": "Wrong. It does not raise KeyError.",
      "3": "Wrong. It mutates the dict by adding 'b'."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "Which module is typically used to encode/decode JSON?",
    "options": [
      "pickle",
      "json",
      "marshal",
      "csv"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. pickle is Python-specific serialization, not JSON.",
      "1": "Correct. The json module handles JSON encoding/decoding.",
      "2": "Wrong. marshal is low-level and not for JSON interchange.",
      "3": "Wrong. csv is for delimited text tables."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What is printed?\n\nprint(sum([1,2,3], 10))",
    "options": [
      "6",
      "13",
      "16",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That would be sum without a start value.",
      "1": "Wrong. 10+1+2+3 is not 13.",
      "2": "Correct. sum(iterable, start) starts from 10 → 16.",
      "3": "Wrong. This usage is valid."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(any([0, '', None, 5]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. any() returns True if any element is truthy (5 is truthy).",
      "1": "Wrong. There is a truthy element.",
      "2": "Wrong. This is valid input.",
      "3": "Wrong. any returns True/False."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(all([1, 'x', [], 3]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on order"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. [] is falsy, making all() False.",
      "1": "Correct. all() requires all elements truthy; [] is falsy.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. all evaluates deterministically."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "Which statement about try/else is TRUE?",
    "options": [
      "else runs only if an exception happens",
      "else runs only if no exception happens",
      "else always runs",
      "else replaces finally"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That’s the except block’s job.",
      "1": "Correct. try/else executes else when no exception occurs.",
      "2": "Wrong. else is conditional on no exception.",
      "3": "Wrong. finally has a different role."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What happens?\n\ntry:\n    1/0\nfinally:\n    print('done')",
    "options": [
      "Prints done and continues normally",
      "Prints done then raises ZeroDivisionError",
      "Raises before printing",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The exception still occurs.",
      "1": "Correct. finally runs, then the exception propagates.",
      "2": "Wrong. finally prints before propagation.",
      "3": "Wrong. Syntax is valid."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "Inside an except block, what does 'raise' with no arguments do?",
    "options": [
      "Raises SyntaxError",
      "Re-raises the current exception",
      "Raises None",
      "Suppresses the exception"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's legal syntax in an except block.",
      "1": "Correct. It re-raises the active exception.",
      "2": "Wrong. It doesn't raise None.",
      "3": "Wrong. It does the opposite of suppressing."
    }
  },
  {
    "topic": "IO",
    "prompt": "Which is TRUE about 'with open(...) as f:'?",
    "options": [
      "It disables buffering",
      "It always loads the file into memory",
      "It automatically closes even if errors happen",
      "It prevents exceptions"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Buffering behavior depends on mode and params.",
      "1": "Wrong. You still read explicitly.",
      "2": "Correct. Context manager closes file on exit.",
      "3": "Wrong. Exceptions can still occur."
    }
  },
  {
    "topic": "IO",
    "prompt": "Which mode opens a file for appending text?",
    "options": [
      "'r'",
      "'w'",
      "'a'",
      "'rb'"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. 'r' is read mode.",
      "1": "Wrong. 'w' truncates and writes.",
      "2": "Correct. 'a' appends to the end.",
      "3": "Wrong. 'rb' is read-binary."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does @staticmethod do?",
    "options": [
      "Passes instance as first arg",
      "Passes class as first arg",
      "No implicit first argument",
      "Makes method private"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That’s normal instance methods.",
      "1": "Wrong. That’s @classmethod.",
      "2": "Correct. staticmethod has no implicit self/cls.",
      "3": "Wrong. Python has no true private methods via decorator."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does @classmethod receive as its first argument?",
    "options": [
      "self",
      "cls",
      "both self and cls",
      "nothing"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. self is for instance methods.",
      "1": "Correct. cls is the class object.",
      "2": "Wrong. It receives only cls implicitly.",
      "3": "Wrong. It does receive cls."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What is printed?\n\nclass A:\n    def f(self):\n        return 'A'\n\nclass B(A):\n    def f(self):\n        return super().f() + 'B'\n\nprint(B().f())",
    "options": [
      "A",
      "B",
      "AB",
      "BA"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. B overrides f and adds 'B'.",
      "1": "Wrong. It includes A's result too.",
      "2": "Correct. super().f() returns 'A', then + 'B' → 'AB'.",
      "3": "Wrong. Order is A then B."
    }
  },
  {
    "topic": "OOP",
    "prompt": "If a class defines __len__ returning 0 and no __bool__, what is bool(obj)?",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends only on __bool__"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __len__ of 0 makes it falsy.",
      "1": "Correct. Python uses __len__ when __bool__ is absent.",
      "2": "Wrong. __len__ returning int is valid.",
      "3": "Wrong. __len__ also affects truthiness."
    }
  },
  {
    "topic": "OOP",
    "prompt": "Which special method enables obj[index]?",
    "options": [
      "__getitem__",
      "__getattr__",
      "__index__",
      "__slice__"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __getitem__ is used for indexing.",
      "1": "Wrong. __getattr__ handles missing attributes.",
      "2": "Wrong. __index__ is for converting an object to an integer index.",
      "3": "Wrong. __slice__ is not used like this in modern Python."
    }
  },
  {
    "topic": "Functional",
    "prompt": "What is the output?\n\nprint(list(map(lambda x: x*x, [1,2,3])))",
    "options": [
      "[1, 4, 9]",
      "[1, 2, 3]",
      "<map object ...>",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. map applies the function to each element.",
      "1": "Wrong. That would be identity function behavior.",
      "2": "Wrong. list(...) forces evaluation; without list it would show a map object.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Functional",
    "prompt": "What does this print?\n\nprint(list(filter(None, [0, 1, '', 'a'])))",
    "options": [
      "[0, 1, '', 'a']",
      "[1, 'a']",
      "['a']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. filter(None, ...) removes falsy values.",
      "1": "Correct. 0 and '' are falsy; 1 and 'a' remain.",
      "2": "Wrong. 1 is also truthy so it remains too.",
      "3": "Wrong. This is valid usage."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "What is the output?\n\nx = {'a': 1, 'b': 2}\nprint(list(x))",
    "options": [
      "['a', 'b'] (in insertion order)",
      "['a', 1, 'b', 2]",
      "[('a',1), ('b',2)]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Iterating a dict yields its keys (in insertion order in modern Python).",
      "1": "Wrong. Iteration does not yield values inline.",
      "2": "Wrong. That would be list(x.items()).",
      "3": "Wrong. list(dict) is valid."
    }
  },
  {
    "topic": "Concurrency",
    "prompt": "Which is TRUE about the Python's Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "It prevents I/O concurrency entirely",
      "It prevents true parallel execution of CPU-bound Python bytecode in threads",
      "It prevents multiprocessing from using multiple cores",
      "It makes asyncio impossible"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. I/O-bound threads can still overlap while waiting on I/O.",
      "1": "Correct. CPU-bound threads won’t run Python bytecode in true parallel. (GIL) is a mutex that ensures only one thread executes Python bytecode at a time in CPython, the standard Python implementation.",
      "2": "Wrong. multiprocessing uses separate processes and can use multiple cores.",
      "3": "Wrong. asyncio is cooperative and works fine."
    }
  },
  {
    "topic": "Concurrency",
    "prompt": "What does 'await' require on the right-hand side?",
    "options": [
      "A normal function",
      "An awaitable (coroutine/future/task)",
      "Only a generator",
      "A thread object"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Normal functions return values immediately; not awaitable.",
      "1": "Correct. await works with awaitables.",
      "2": "Wrong. Generators are not awaitables unless wrapped/converted.",
      "3": "Wrong. Threads are not awaitables by default."
    }
  },
  {
    "topic": "Typing",
    "prompt": "typing.Optional[int] means:",
    "options": [
      "int only",
      "int or None",
      "any type",
      "a required int"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Optional allows None.",
      "1": "Correct. Optional[int] == Union[int, None].",
      "2": "Wrong. That would be Any.",
      "3": "Wrong. Optional is the opposite of required-only."
    }
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\ns = 'abc'\ntry:\n    s[0] = 'z'\nexcept Exception as e:\n    print(type(e).__name__)",
    "options": [
      "ValueError",
      "TypeError",
      "IndexError",
      "No output"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Not a ValueError.",
      "1": "Correct. Strings are immutable; item assignment raises TypeError.",
      "2": "Wrong. Index 0 is valid; immutability is the issue.",
      "3": "Wrong. The exception is caught and printed."
    }
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nprint([1,2] == [1,2], [1,2] is [1,2])",
    "options": [
      "True True",
      "True False",
      "False True",
      "False False"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Separate list literals are different objects → 'is' is False.",
      "1": "Correct. Values equal, identities differ.",
      "2": "Wrong. Equality is True here.",
      "3": "Wrong. Equality is True."
    }
  },
  {
    "topic": "Dicts",
    "prompt": "Which statement about dict membership is TRUE?\n\n('x' in {'x': 1})",
    "options": [
      "Checks values for membership",
      "Checks keys for membership",
      "Raises TypeError",
      "Depends on hash seed"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 'in' on a dict checks keys, not values.",
      "1": "Correct. Dict membership tests keys.",
      "2": "Wrong. It's valid.",
      "3": "Wrong. Meaning is deterministic; hash seed doesn't change correctness."
    }
  },
  {
    "topic": "Decorators",
    "prompt": "What does this print?\n\ndef deco(f):\n    def wrapper(*a, **k):\n        return f(*a, **k) + 1\n    return wrapper\n\n@deco\ndef f():\n    return 10\n\nprint(f())",
    "options": ["10", "11", "TypeError", "wrapper"],
    "correct": [1],
    "explanations": {
      "0": "Wrong. The decorator modifies the function result.",
      "1": "Correct. wrapper calls f() (10) then adds 1.",
      "2": "Wrong. All operations are valid.",
      "3": "Wrong. It prints the return value, not the function object."
    }
  },
  {
    "topic": "Closures",
    "prompt": "What does this print?\n\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda: i)\n\nprint([f() for f in funcs])",
    "options": ["[0, 1, 2]", "[2, 2, 2]", "[3, 3, 3]", "Raises NameError"],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Late binding means lambdas read i when called, not when created.",
      "1": "Correct. i ends at 2, so all lambdas return 2.",
      "2": "Wrong. range(3) ends with i == 2.",
      "3": "Wrong. i exists in the enclosing scope at call time."
    }
  },
  {
    "topic": "Closures",
    "prompt": "How do you fix the late-binding issue in the previous code (best answer)?",
    "options": [
      "Use lambda i=i: i",
      "Use global i",
      "Convert i to str",
      "Use nonlocal i"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. Default args capture the current value at definition time.",
      "1": "Wrong. global doesn't capture per-iteration values.",
      "2": "Wrong. Type conversion doesn't address binding.",
      "3": "Wrong. nonlocal is for assigning into enclosing scopes, not capturing loop values."
    }
  },
  {
    "topic": "Context Managers",
    "prompt": "What does this print?\n\nclass C:\n    def __enter__(self):\n        print('enter')\n        return 123\n    def __exit__(self, exc_type, exc, tb):\n        print('exit')\n        return True\n\nwith C() as x:\n    print(x)\n    1/0\nprint('after')",
    "options": [
      "enter\\n123\\nexit\\nafter",
      "enter\\n123\\nexit",
      "enter\\n123 then ZeroDivisionError",
      "enter\\nexit then ZeroDivisionError"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. __exit__ returns True which suppresses the exception, then execution continues.",
      "1": "Wrong. It continues to print 'after' because exception is suppressed.",
      "2": "Wrong. Exception is suppressed due to return True in __exit__.",
      "3": "Wrong. The body prints x before the exception occurs."
    }
  },
  {
    "topic": "Iteration Protocol",
    "prompt": "Which statement is TRUE about iterators?",
    "options": [
      "Every iterable is an iterator",
      "An iterator must implement __iter__ and __next__",
      "__iter__ must return a new independent iterator each time",
      "Iterators can be restarted by calling iter(it)"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Iterables produce iterators; they aren't necessarily iterators themselves.",
      "1": "Correct. That's the core iterator protocol.",
      "2": "Wrong. That's typical for iterables; iterators usually return themselves from __iter__.",
      "3": "Wrong. Most iterators are one-shot and cannot be restarted."
    }
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this produce?\n\n{x: x*x for x in [1,1,2]}",
    "options": [
      "{1: 1, 2: 4} (last wins)",
      "{1: 1, 1: 1, 2: 4}",
      "{1: 1, 2: 2}",
      "Raises ValueError for duplicate keys"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. Dict keys are unique; later assignments overwrite earlier ones.",
      "1": "Wrong. Dicts cannot contain duplicate keys.",
      "2": "Wrong. Value for 2 should be 4.",
      "3": "Wrong. No error is raised."
    }
  },
  {
    "topic": "Dataclasses",
    "prompt": "What is TRUE about a frozen dataclass?",
    "options": [
      "It prevents rebinding of all variables",
      "It prevents attribute assignment (like immutability) after creation",
      "It deep-freezes nested mutable fields",
      "It cannot have default values"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. It only affects dataclass instance attribute assignment, not variables outside.",
      "1": "Correct. Frozen prevents setting attributes after init.",
      "2": "Wrong. Nested objects can still be mutated if they are mutable.",
      "3": "Wrong. Frozen dataclasses can still have defaults."
    }
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    raise ValueError('x')\nexcept Exception as e:\n    print(type(e).__name__)\nelse:\n    print('else')\nfinally:\n    print('finally')",
    "options": [
      "ValueError\\nfinally",
      "Exception\\nelse\\nfinally",
      "ValueError\\nelse\\nfinally",
      "ValueError only"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. except runs, else does not, finally always runs.",
      "1": "Wrong. The exception type printed is ValueError, not Exception.",
      "2": "Wrong. else doesn't run when an exception occurs.",
      "3": "Wrong. finally always runs."
    }
  },
  {
    "topic": "Imports",
    "prompt": "Which is TRUE about `import module` vs `from module import name`?",
    "options": [
      "They are identical in all cases",
      "`from module import name` binds `name` directly in the importing namespace",
      "`import module` binds all module attributes into globals",
      "`from module import name` prevents module code from executing"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. They bind different names in the importing scope.",
      "1": "Correct. The imported name is bound directly (no module prefix needed).",
      "2": "Wrong. `import module` binds the module object only.",
      "3": "Wrong. Module code still executes on first import."
    }
  },
  {
    "topic": "Async",
    "prompt": "What does `await` require?",
    "options": [
      "A regular function",
      "An awaitable (coroutine/future/task)",
      "A generator expression",
      "A thread object"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Regular functions are not awaitable.",
      "1": "Correct. await works with awaitables.",
      "2": "Wrong. Generators are not awaitables unless adapted.",
      "3": "Wrong. Threads are not awaitables by default."
    }
  },
  {
    "topic": "GIL",
    "prompt": "Which statement best describes the CPython GIL?",
    "options": [
      "Threads cannot be used at all",
      "Threads cannot run CPU-bound Python bytecode in true parallel",
      "Multiprocessing is also limited to one core",
      "Asyncio bypasses the GIL for CPU work"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Threads can be useful for I/O-bound workloads.",
      "1": "Correct. CPU-bound work doesn't gain true parallelism in threads under CPython.",
      "2": "Wrong. Multiprocessing uses multiple processes and can use multiple cores.",
      "3": "Wrong. Asyncio is cooperative; CPU work still blocks unless offloaded."
    }
  },
  {
    "topic": "Mutability",
    "prompt": "What does this print?\n\na = ([],)\na[0].append(1)\nprint(a)",
    "options": [
      "TypeError because tuple is immutable",
      "([],)",
      "([1],)",
      "Raises AttributeError"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. The tuple can't be rebound, but the list inside can be mutated.",
      "1": "Wrong. The list was appended to.",
      "2": "Correct. The list inside the tuple becomes [1].",
      "3": "Wrong. list.append exists."
    }
  },
  {
    "topic": "Descriptors",
    "prompt": "Which mechanism powers `@property`?",
    "options": [
      "Metaclasses only",
      "Descriptors (__get__/__set__)",
      "Monkey patching",
      "The GIL"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Metaclasses are not required for property.",
      "1": "Correct. property implements the descriptor protocol.",
      "2": "Wrong. Monkey patching is unrelated.",
      "3": "Wrong. The GIL is unrelated."
    }
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    x = 1\n\nclass B(A):\n    x = 2\n\nprint(A.x, B.x, B().x)",
    "options": [
      "1 1 1",
      "1 2 2",
      "2 2 1",
      "2 1 2"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. B overrides x.",
      "1": "Correct. A.x=1, B.x=2, instance finds B.x=2.",
      "2": "Wrong. A.x stays 1.",
      "3": "Wrong. A.x is not 2."
    }
  },
  {
    "topic": "Hashing",
    "prompt": "Why can a tuple be used as a dict key but a list cannot (in general)?",
    "options": [
      "Tuples are faster",
      "Lists are ordered",
      "Tuples are (generally) immutable and hashable; lists are mutable and unhashable",
      "Lists cannot contain strings"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Speed isn't the rule for hashability.",
      "1": "Wrong. Both are ordered sequences.",
      "2": "Correct. Mutability breaks hash invariants.",
      "3": "Wrong. Lists can contain strings."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What does Optional[int] mean?",
    "options": [
      "int only",
      "int or None",
      "any type",
      "a required int"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Optional includes None.",
      "1": "Correct. Optional[int] == Union[int, None].",
      "2": "Wrong. That would be Any.",
      "3": "Wrong. Optional suggests it can be None."
    }
  },
  {
    "topic": "Functional",
    "prompt": "What does this print?\n\nprint(list(filter(None, [0, 1, '', 'a', None])))",
    "options": [
      "[0, 1, '', 'a', None]",
      "[1, 'a']",
      "['a']",
      "TypeError"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. filter(None, ...) removes falsy values.",
      "1": "Correct. Keeps truthy values: 1 and 'a'.",
      "2": "Wrong. 1 is also truthy.",
      "3": "Wrong. This is valid."
    }
  },
  {
    "topic": "Evaluation Order",
    "prompt": "What does this print?\n\nx = 0\nx = x + 1 if True else x + 100\nprint(x)",
    "options": [
      "0",
      "1",
      "100",
      "101"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. The conditional expression takes the True branch.",
      "1": "Correct. True branch evaluates to x+1 (0+1).",
      "2": "Wrong. Else branch is not evaluated.",
      "3": "Wrong. Only one branch is evaluated."
    }
  },
  {
    "topic": "Stdlib",
    "prompt": "What is the output?\n\nimport math\nprint(math.isclose(0.1 + 0.2, 0.3))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on OS"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. isclose checks approximate equality with tolerances.",
      "1": "Wrong. isclose is designed for floating-point comparisons.",
      "2": "Wrong. This is valid usage.",
      "3": "Wrong. Deterministic."
    }
  },
  {
    "topic": "Performance",
    "prompt": "Which is generally more memory-efficient for large sequences?",
    "options": [
      "List comprehension",
      "Generator expression",
      "Building a list then iterating",
      "Converting to tuple first"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Lists materialize all items immediately.",
      "1": "Correct. Generators produce items lazily.",
      "2": "Wrong. It creates the whole list in memory.",
      "3": "Wrong. Tuples still store all items."
    }
  },
  {
    "topic": "MRO",
    "prompt": "What determines method resolution order (MRO) in Python?",
    "options": [
      "Depth-first search",
      "Breadth-first search",
      "C3 linearization",
      "Order of class definition"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Python does not use naive depth-first search.",
      "1": "Wrong. Breadth-first alone is insufficient.",
      "2": "Correct. Python uses C3 linearization for MRO.",
      "3": "Wrong. Definition order alone is not sufficient."
    }
  },
  {
    "topic": "MRO",
    "prompt": "What does this print?\n\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass\n\nprint(D.__mro__)",
    "options": [
      "(D, B, C, A, object)",
      "(D, C, B, A, object)",
      "(D, B, A, C, object)",
      "Raises TypeError"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. This follows C3 linearization.",
      "1": "Wrong. Order of bases is respected.",
      "2": "Wrong. A must come after both B and C.",
      "3": "Wrong. This hierarchy is valid."
    }
  },
  {
    "topic": "Descriptors",
    "prompt": "Which methods define the descriptor protocol?",
    "options": [
      "__get__ only",
      "__get__ and __set__",
      "__get__, __set__, and __delete__",
      "__call__"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Descriptors can define more than __get__.",
      "1": "Wrong. __delete__ is also part of the protocol.",
      "2": "Correct. These three define descriptor behavior.",
      "3": "Wrong. __call__ is unrelated."
    }
  },
  {
    "topic": "Descriptors",
    "prompt": "Which built-in feature relies on descriptors?",
    "options": [
      "for loops",
      "@property",
      "lambda",
      "try/except"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Iteration does not use descriptors.",
      "1": "Correct. property is implemented using descriptors.",
      "2": "Wrong. Lambdas are functions.",
      "3": "Wrong. Exception handling is unrelated."
    }
  },
  {
    "topic": "Weak References",
    "prompt": "What is the purpose of weakref?",
    "options": [
      "Improve performance",
      "Prevent garbage collection",
      "Reference objects without preventing GC",
      "Make objects immutable"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. weakref is about lifecycle, not speed.",
      "1": "Wrong. weak references do not prevent GC.",
      "2": "Correct. weakref allows GC when no strong refs exist.",
      "3": "Wrong. It does not affect mutability."
    }
  },
  {
    "topic": "Garbage Collection",
    "prompt": "What does reference counting fail to handle without GC?",
    "options": [
      "Large objects",
      "Immutable objects",
      "Circular references",
      "Function calls"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Size is irrelevant.",
      "1": "Wrong. Immutability does not affect reference counting.",
      "2": "Correct. Cycles require cyclic garbage collection.",
      "3": "Wrong. Calls do not cause leaks."
    }
  },
  {
    "topic": "Contextlib",
    "prompt": "What does @contextmanager allow you to do?",
    "options": [
      "Create decorators",
      "Create generators",
      "Create context managers using yield",
      "Suppress exceptions globally"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. contextmanager is not for decorators in general.",
      "1": "Wrong. Though it uses yield, its purpose is context management.",
      "2": "Correct. yield splits enter and exit logic.",
      "3": "Wrong. Exception suppression is optional."
    }
  },
  {
    "topic": "Contextlib",
    "prompt": "If a contextmanager generator does not yield, what happens?",
    "options": [
      "Nothing",
      "RuntimeError",
      "StopIteration",
      "SyntaxError"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. The context requires a yield.",
      "1": "Correct. A RuntimeError is raised.",
      "2": "Wrong. StopIteration is internal.",
      "3": "Wrong. Syntax is valid."
    }
  },
  {
    "topic": "Functools",
    "prompt": "What does functools.lru_cache do?",
    "options": [
      "Caches results of function calls",
      "Caches function bytecode",
      "Optimizes recursion only",
      "Makes functions thread-safe"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. Results are memoized based on arguments.",
      "1": "Wrong. Bytecode is not cached this way.",
      "2": "Wrong. It works for any function.",
      "3": "Wrong. Thread safety is not guaranteed."
    }
  },
  {
    "topic": "Functools",
    "prompt": "What happens when lru_cache reaches maxsize?",
    "options": [
      "Cache clears entirely",
      "Oldest entries are evicted",
      "Newest entries are evicted",
      "Raises MemoryError"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Cache is not fully cleared.",
      "1": "Correct. Least recently used entries are evicted.",
      "2": "Wrong. New entries are retained.",
      "3": "Wrong. Eviction prevents memory errors."
    }
  },
  {
    "topic": "Itertools",
    "prompt": "Which itertools function groups consecutive items?",
    "options": [
      "groupby",
      "combinations",
      "product",
      "chain"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. groupby groups adjacent elements.",
      "1": "Wrong. combinations creates tuples.",
      "2": "Wrong. product computes Cartesian products.",
      "3": "Wrong. chain concatenates iterables."
    }
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.count() produce?",
    "options": [
      "A finite range",
      "An infinite iterator",
      "A list",
      "Raises StopIteration"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. count is unbounded.",
      "1": "Correct. It produces an infinite sequence.",
      "2": "Wrong. It yields values lazily.",
      "3": "Wrong. It never stops."
    }
  },
  {
    "topic": "Memory",
    "prompt": "Which object typically uses the least memory?",
    "options": [
      "List",
      "Tuple",
      "Set",
      "Dict"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Lists have extra capacity overhead.",
      "1": "Correct. Tuples are compact and immutable.",
      "2": "Wrong. Sets require hashing overhead.",
      "3": "Wrong. Dicts store key-value pairs."
    }
  },
  {
    "topic": "CPython Internals",
    "prompt": "What is Python bytecode?",
    "options": [
      "Machine code",
      "Intermediate representation executed by the VM",
      "Assembly language",
      "Source code"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Bytecode is not machine code.",
      "1": "Correct. Bytecode is run by the Python virtual machine.",
      "2": "Wrong. Assembly is lower-level.",
      "3": "Wrong. Bytecode is compiled from source."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "What is the primary purpose of the asyncio event loop?",
    "options": [
      "Run threads in parallel",
      "Schedule and run asynchronous tasks",
      "Replace the operating system scheduler",
      "Execute CPU-bound code faster"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. asyncio does not manage OS threads.",
      "1": "Correct. The event loop schedules and runs async tasks cooperatively.",
      "2": "Wrong. The OS scheduler is unchanged.",
      "3": "Wrong. Asyncio does not speed up CPU-bound work."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "What happens if you call an async function without awaiting it?",
    "options": [
      "It runs immediately",
      "It raises a SyntaxError",
      "It returns a coroutine object",
      "It blocks the event loop"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Async functions do not execute until awaited.",
      "1": "Wrong. This is syntactically valid.",
      "2": "Correct. Calling returns a coroutine object.",
      "3": "Wrong. Nothing runs yet."
    }
  },
  {
    "topic": "Asyncio",
    "prompt": "Which function is used to run the asyncio event loop in Python 3.7+?",
    "options": [
      "loop.run()",
      "asyncio.execute()",
      "asyncio.run()",
      "asyncio.start()"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. loop.run is not the public API.",
      "1": "Wrong. This function does not exist.",
      "2": "Correct. asyncio.run() is the recommended entry point.",
      "3": "Wrong. This function does not exist."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What does typing.Protocol enable?",
    "options": [
      "Runtime type enforcement",
      "Nominal subtyping",
      "Structural subtyping",
      "Duck typing removal"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Protocols are for static typing.",
      "1": "Wrong. Protocols avoid nominal inheritance.",
      "2": "Correct. Protocols enable structural (duck-typed) subtyping.",
      "3": "Wrong. Protocols formalize duck typing."
    }
  },
  {
    "topic": "Typing",
    "prompt": "What is the runtime effect of type hints?",
    "options": [
      "They enforce types automatically",
      "They slow down execution",
      "They are mostly ignored at runtime",
      "They prevent invalid assignments"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Python does not enforce types by default.",
      "1": "Wrong. They usually have no runtime cost.",
      "2": "Correct. Type hints are for tooling, not enforcement.",
      "3": "Wrong. Invalid assignments are still allowed."
    }
  },
  {
    "topic": "Metaclasses",
    "prompt": "When is a metaclass __new__ method executed?",
    "options": [
      "When an instance is created",
      "When a class is defined",
      "When a module is imported",
      "When __init__ is called"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Instance creation is handled later.",
      "1": "Correct. Metaclasses control class creation.",
      "2": "Wrong. Imports may trigger class definition, but not always.",
      "3": "Wrong. __init__ refers to instances."
    }
  },
  {
    "topic": "Metaclasses",
    "prompt": "Which keyword argument is passed to a metaclass __new__?",
    "options": [
      "self",
      "cls",
      "bases",
      "locals"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. self is for instances.",
      "1": "Wrong. cls refers to the metaclass itself.",
      "2": "Correct. bases contains base classes of the new class.",
      "3": "Wrong. locals are passed as a dict, not as this name."
    }
  },
  {
    "topic": "Imports",
    "prompt": "Where are imported modules cached?",
    "options": [
      "globals()",
      "builtins",
      "sys.modules",
      "__all__"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. globals only affect the current module.",
      "1": "Wrong. builtins is separate.",
      "2": "Correct. sys.modules caches loaded modules.",
      "3": "Wrong. __all__ controls export behavior."
    }
  },
  {
    "topic": "Imports",
    "prompt": "What happens if you delete an entry from sys.modules?",
    "options": [
      "The module is unloaded from memory",
      "The module cannot be imported again",
      "The next import reloads the module",
      "Python crashes"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Other references may still exist.",
      "1": "Wrong. It can be re-imported.",
      "2": "Correct. The next import reloads the module.",
      "3": "Wrong. This is safe (though advanced)."
    }
  },
  {
    "topic": "Multiprocessing",
    "prompt": "Why does multiprocessing bypass the GIL?",
    "options": [
      "It disables the GIL",
      "Each process has its own interpreter",
      "It rewrites Python bytecode",
      "It uses async IO"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. The GIL still exists per process.",
      "1": "Correct. Each process has its own GIL.",
      "2": "Wrong. Bytecode is unchanged.",
      "3": "Wrong. Async IO is unrelated."
    }
  },
  {
    "topic": "Multiprocessing",
    "prompt": "What must be true for objects sent between processes?",
    "options": [
      "They must be hashable",
      "They must be immutable",
      "They must be picklable",
      "They must be threadsafe"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Hashability is irrelevant.",
      "1": "Wrong. Mutable objects can be pickled.",
      "2": "Correct. Objects are serialized via pickle.",
      "3": "Wrong. Thread safety is unrelated."
    }
  },
  {
    "topic": "Collections",
    "prompt": "What does collections.defaultdict provide?",
    "options": [
      "Automatic key deletion",
      "Default values for missing keys",
      "Thread safety",
      "Ordered iteration"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Keys are not deleted.",
      "1": "Correct. Missing keys are created automatically.",
      "2": "Wrong. defaultdict is not thread-safe.",
      "3": "Wrong. Order depends on insertion."
    }
  },
  {
    "topic": "Collections",
    "prompt": "What does collections.deque provide over list?",
    "options": [
      "Faster random access",
      "Efficient appends and pops from both ends",
      "Automatic sorting",
      "Lower memory usage in all cases"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Deque is not optimized for random access.",
      "1": "Correct. Deque is optimized for both ends.",
      "2": "Wrong. Deque does not sort.",
      "3": "Wrong. Memory usage varies."
    }
  },
  {
    "topic": "Evaluation",
    "prompt": "What does short-circuit evaluation mean?",
    "options": [
      "Expressions are evaluated faster",
      "Later operands may not be evaluated",
      "Evaluation happens in parallel",
      "Exceptions are suppressed"
    ],
    "correct": [1],
    "explanations": {
      "0": "Wrong. Speed is not guaranteed.",
      "1": "Correct. Logical operators may skip evaluation.",
      "2": "Wrong. Evaluation is sequential.",
      "3": "Wrong. Exceptions are not suppressed."
    }
  },
  {
    "topic": "Evaluation",
    "prompt": "What does this print?\n\nprint(False and (1/0))",
    "options": [
      "False",
      "ZeroDivisionError",
      "None",
      "True"
    ],
    "correct": [0],
    "explanations": {
      "0": "Correct. The second operand is never evaluated.",
      "1": "Wrong. Short-circuit prevents evaluation.",
      "2": "Wrong. The result is False.",
      "3": "Wrong. False and anything is False."
    }
  },
  {
    "topic": "Performance",
    "prompt": "Which is typically the fastest membership test?",
    "options": [
      "x in list",
      "x in tuple",
      "x in set",
      "x in string"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. List membership is O(n).",
      "1": "Wrong. Tuple membership is O(n).",
      "2": "Correct. Set membership is O(1) average case.",
      "3": "Wrong. Strings require scanning."
    }
  },
  {
    "topic": "Security",
    "prompt": "Why is eval() dangerous?",
    "options": [
      "It is slow",
      "It cannot evaluate expressions",
      "It can execute arbitrary code",
      "It leaks memory"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. Speed is not the primary risk.",
      "1": "Wrong. eval can evaluate expressions.",
      "2": "Correct. eval executes arbitrary code.",
      "3": "Wrong. Memory leaks are not the main concern."
    }
  },
  {
    "topic": "Security",
    "prompt": "Which is safer than eval for parsing literals?",
    "options": [
      "exec",
      "compile",
      "ast.literal_eval",
      "globals"
    ],
    "correct": [2],
    "explanations": {
      "0": "Wrong. exec is also dangerous.",
      "1": "Wrong. compile does not restrict execution.",
      "2": "Correct. literal_eval safely parses literals only.",
      "3": "Wrong. globals exposes namespace."
    }
  }
]