[
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(type(3/2))",
    "options": [
      "<class 'int'>",
      "<class 'float'>",
      "<class 'decimal.Decimal'>",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. / always returns a float in Python 3.",
      "1": "Correct. 3/2 evaluates to 1.5 (float).",
      "2": "Wrong. Decimal is only used if explicitly created.",
      "3": "Wrong. No exception is raised."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "Which statement about '==' and 'is' is TRUE?",
    "options": [
      "'is' compares values",
      "'==' compares identity",
      "'==' compares values; 'is' compares identity",
      "They are interchangeable"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. 'is' checks identity (same object).",
      "1": "Wrong. '==' checks value equality.",
      "2": "Correct. Value vs identity is the key distinction.",
      "3": "Wrong. They are not interchangeable."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nprint(0.1 + 0.2 == 0.3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on OS"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Floating-point rounding prevents exact equality here.",
      "1": "Correct. 0.1+0.2 is not exactly 0.3 in binary floating point.",
      "2": "Wrong. No exception is raised.",
      "3": "Wrong. This behavior is consistent across platforms."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Truthiness",
    "prompt": "Which values are falsy in Python? (Select ALL that apply)",
    "options": [
      "0",
      "''",
      "[]",
      "'0'"
    ],
    "correct": [
      0,
      1,
      2
    ],
    "explanations": {
      "0": "Correct. Numeric zero is falsy.",
      "1": "Correct. Empty string is falsy.",
      "2": "Correct. Empty list is falsy.",
      "3": "Wrong. Non-empty strings are truthy even if they look like zero."
    },
    "ikm_pdf_mapping": "Python Control Flow"
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint(bool([0]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Any non-empty list is truthy.",
      "1": "Wrong. The list is not empty.",
      "2": "Wrong. bool(list) is valid.",
      "3": "Wrong. bool returns True/False."
    },
    "ikm_pdf_mapping": "Python Control Flow"
  },
  {
    "topic": "Data Structures",
    "prompt": "Which are valid dictionary keys? (Select ALL that apply)",
    "options": [
      "('a', 1)",
      "['a', 1]",
      "{'a': 1}",
      "42"
    ],
    "correct": [
      0,
      3
    ],
    "explanations": {
      "0": "Correct. Tuples are hashable if elements are hashable.",
      "1": "Wrong. Lists are mutable \u2192 unhashable.",
      "2": "Wrong. Dicts are mutable \u2192 unhashable.",
      "3": "Correct. Integers are hashable."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2,3]\ny = x\nx.append(4)\nprint(y)",
    "options": [
      "[1,2,3]",
      "[1,2,3,4]",
      "[4]",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y references the same list as x.",
      "1": "Correct. Both variables point to the same list object.",
      "2": "Wrong. append mutates the list; it doesn\u2019t replace it with [4].",
      "3": "Wrong. No variable is missing."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2,3]\ny = x[:]\nx.append(4)\nprint(y)",
    "options": [
      "[1,2,3,4]",
      "[1,2,3]",
      "[]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y is a copy; it doesn't see x's append.",
      "1": "Correct. Slicing creates a shallow copy of the list.",
      "2": "Wrong. The copy contains elements.",
      "3": "Wrong. This is valid Python."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = (1)\nprint(type(x))",
    "options": [
      "<class 'tuple'>",
      "<class 'int'>",
      "<class 'list'>",
      "<class 'float'>"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Parentheses alone do not make a tuple.",
      "1": "Correct. (1) is just the integer 1.",
      "2": "Wrong. Lists use square brackets.",
      "3": "Wrong. No float conversion occurs."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = (1,)\nprint(type(x))",
    "options": [
      "<class 'tuple'>",
      "<class 'int'>",
      "<class 'list'>",
      "<class 'float'>"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. The trailing comma makes it a tuple.",
      "1": "Wrong. (1,) is not an int.",
      "2": "Wrong. Not a list.",
      "3": "Wrong. Not a float."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Generators",
    "prompt": "Which create a generator? (Select ALL that apply)",
    "options": [
      "(x for x in range(3))",
      "[x for x in range(3)]",
      "def f():\n    yield 1",
      "{x for x in range(3)}"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. Generator expression.",
      "1": "Wrong. List comprehension creates a list.",
      "2": "Correct. 'yield' makes a generator function.",
      "3": "Wrong. Set comprehension creates a set."
    },
    "ikm_pdf_mapping": "Python Generators and Coroutines"
  },
  {
    "topic": "Generators",
    "prompt": "What happens when a generator is exhausted?",
    "options": [
      "Returns None",
      "Restarts automatically",
      "Raises StopIteration",
      "Loops forever"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. It doesn\u2019t return None to signal end.",
      "1": "Wrong. Generators do not restart on their own.",
      "2": "Correct. Iteration ends via StopIteration.",
      "3": "Wrong. It terminates."
    },
    "ikm_pdf_mapping": "Python Generators and Coroutines"
  },
  {
    "topic": "Sets",
    "prompt": "What is the result of: len({1,2,2,3})",
    "options": [
      "4",
      "3",
      "2",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Duplicates are removed.",
      "1": "Correct. The set is {1,2,3}.",
      "2": "Wrong. There are three unique elements.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Pitfalls",
    "prompt": "What does this print?\n\nprint([[]] * 2)",
    "options": [
      "[[], []] independent lists",
      "[[]] twice",
      "Two references to the same inner list",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. The inner list is shared (same object repeated).",
      "1": "Wrong. It becomes a list of length 2, not a nested repetition conceptually.",
      "2": "Correct. List multiplication repeats references to the same object.",
      "3": "Wrong. No error."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Functions",
    "prompt": "Which statement about default arguments is TRUE?",
    "options": [
      "Evaluated at call time",
      "Evaluated once at function definition",
      "Reset every call",
      "Must be immutable"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Defaults are evaluated when the def runs (definition time).",
      "1": "Correct. This is why mutable defaults can be dangerous.",
      "2": "Wrong. They persist across calls.",
      "3": "Wrong. They can be mutable; it\u2019s just often a pitfall."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(x, acc=[]):\n    acc.append(x)\n    return acc\n\nprint(f(1))\nprint(f(2))",
    "options": [
      "[1] then [2]",
      "[1] then [1, 2]",
      "[1] then [1]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. acc is the same list each call.",
      "1": "Correct. The default list is reused and grows.",
      "2": "Wrong. It doesn\u2019t reset automatically.",
      "3": "Wrong. Valid code."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 10\n\ndef g():\n    x = 5\n\ng()\nprint(x)",
    "options": [
      "5",
      "10",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Local assignment does not affect global x.",
      "1": "Correct. The global x stays 10.",
      "2": "Wrong. No read-before-assign occurs here.",
      "3": "Wrong. x exists globally."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Scope",
    "prompt": "What happens?\n\nx = 1\n\ndef h():\n    print(x)\n    x = 2\n\nh()",
    "options": [
      "Prints 1",
      "Prints 2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python treats x as local due to assignment in the function.",
      "1": "Wrong. It fails before printing.",
      "2": "Correct. Local variable referenced before assignment.",
      "3": "Wrong. Name exists, but scope rules make it local."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Scope",
    "prompt": "Which keyword allows assigning to a variable in an enclosing (non-global) scope?",
    "options": [
      "global",
      "nonlocal",
      "outer",
      "static"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. global targets module scope, not enclosing function scope.",
      "1": "Correct. nonlocal targets nearest enclosing function scope.",
      "2": "Wrong. Not a Python keyword.",
      "3": "Wrong. Not a Python keyword."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a' < 'B')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on locale"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Unicode code points put 'B' before 'a'.",
      "1": "Correct. 'B' has a smaller code point than 'a'.",
      "2": "Wrong. String comparisons are valid.",
      "3": "Wrong. Python uses Unicode code points, not locale."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What is the output?\n\nprint(','.join(['a', 'b', 'c']))",
    "options": [
      "a b c",
      "a,b,c",
      "['a','b','c']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. join uses the separator exactly (comma here).",
      "1": "Correct. Comma-separated string.",
      "2": "Wrong. That would be repr of a list, not join output.",
      "3": "Wrong. join works with strings."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "Which converts bytes to str using UTF-8?",
    "options": [
      "b.encode('utf-8')",
      "b.decode('utf-8')",
      "str(b)",
      "bytes(b)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. encode converts str -> bytes.",
      "1": "Correct. decode converts bytes -> str.",
      "2": "Wrong. str(b) produces a representation like \"b'...'\".",
      "3": "Wrong. bytes(b) expects an int iterable or buffer; not decoding."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('hello'[:3])",
    "options": [
      "hel",
      "ell",
      "llo",
      "IndexError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Slice from start up to index 3 (exclusive).",
      "1": "Wrong. That would be 'hello'[1:4].",
      "2": "Wrong. That would be 'hello'[2:5].",
      "3": "Wrong. Slicing is safe; no IndexError."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Sequences",
    "prompt": "Which statement about slicing is TRUE? (Select ALL that apply)",
    "options": [
      "Slicing a list returns a new list",
      "Slicing deep-copies nested objects",
      "Slicing supports a step value",
      "Slicing always returns a view"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. It creates a new list object (shallow copy).",
      "1": "Wrong. It\u2019s a shallow copy; nested objects are shared.",
      "2": "Correct. list[start:stop:step] supports step.",
      "3": "Wrong. Python list slicing is not a view (unlike some libraries)."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Sequences",
    "prompt": "What is printed?\n\nx = [1,2,3]\nx[1:2] = [9,9]\nprint(x)",
    "options": [
      "[1, 9, 3]",
      "[1, 9, 9, 3]",
      "[9, 9]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Replacing a slice can change length; here it inserts two items.",
      "1": "Correct. The slice [2] is replaced by [9,9].",
      "2": "Wrong. That would replace the whole list.",
      "3": "Wrong. Slice assignment is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Sorting",
    "prompt": "What does this print?\n\nprint(sorted(['10','2','1']))",
    "options": [
      "['1','2','10']",
      "['10','1','2']",
      "['10','2','1']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That would be numeric sort, but these are strings.",
      "1": "Correct. Lexicographic string order: '10' < '1' < '2' is false; actual is '10','1','2'.",
      "2": "Wrong. That\u2019s the original order, not sorted.",
      "3": "Wrong. Sorting strings is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Sorting",
    "prompt": "How do you sort numbers by absolute value?",
    "options": [
      "sorted(nums, key=abs)",
      "sorted(abs(nums))",
      "nums.sort(abs)",
      "sort(nums, abs)"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. key=abs sorts by absolute value.",
      "1": "Wrong. abs(nums) is invalid for a list.",
      "2": "Wrong. list.sort takes keyword key=..., not a positional function like that.",
      "3": "Wrong. sort(...) is not a built-in function in that form."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does enumerate(iterable) produce?",
    "options": [
      "Only items",
      "Only indexes",
      "Pairs of (index, item)",
      "Triples of (index, item, length)"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. It includes indexes too.",
      "1": "Wrong. It includes items too.",
      "2": "Correct. enumerate yields (index, value) pairs.",
      "3": "Wrong. No length is included."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What is printed?\n\nprint(list(zip([1,2,3], ['a','b'])))",
    "options": [
      "[(1,'a'), (2,'b')]",
      "[(1,'a'), (2,'b'), (3,None)]",
      "TypeError",
      "[(1,'a'), (2,'b'), (3,'c')]"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. zip stops at the shortest iterable.",
      "1": "Wrong. zip does not pad with None by default.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. 'c' is not present."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Dicts",
    "prompt": "What does dict.get('k', 99) return if 'k' is missing?",
    "options": [
      "Raises KeyError",
      "Returns None always",
      "Returns 99",
      "Adds 'k' with 99"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. get does not raise KeyError.",
      "1": "Wrong. It returns default if provided.",
      "2": "Correct. Default is returned when key is missing.",
      "3": "Wrong. get does not mutate the dict."
    },
    "ikm_pdf_mapping": "Python Dictionaries"
  },
  {
    "topic": "Dicts",
    "prompt": "What does this print?\n\nd = {'a': 1}\nprint(d.setdefault('b', 2), d)",
    "options": [
      "2 {'a': 1, 'b': 2}",
      "None {'a': 1}",
      "KeyError",
      "2 {'a': 1}"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. setdefault inserts missing key and returns the value.",
      "1": "Wrong. It will insert 'b' and return 2.",
      "2": "Wrong. It does not raise KeyError.",
      "3": "Wrong. It mutates the dict by adding 'b'."
    },
    "ikm_pdf_mapping": "Python Dictionaries"
  },
  {
    "topic": "Stdlib",
    "prompt": "Which module is typically used to encode/decode JSON?",
    "options": [
      "pickle",
      "json",
      "marshal",
      "csv"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. pickle is Python-specific serialization, not JSON.",
      "1": "Correct. The json module handles JSON encoding/decoding.",
      "2": "Wrong. marshal is low-level and not for JSON interchange.",
      "3": "Wrong. csv is for delimited text tables."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What is printed?\n\nprint(sum([1,2,3], 10))",
    "options": [
      "6",
      "13",
      "16",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That would be sum without a start value.",
      "1": "Wrong. 10+1+2+3 is not 13.",
      "2": "Correct. sum(iterable, start) starts from 10 \u2192 16.",
      "3": "Wrong. This usage is valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(any([0, '', None, 5]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. any() returns True if any element is truthy (5 is truthy).",
      "1": "Wrong. There is a truthy element.",
      "2": "Wrong. This is valid input.",
      "3": "Wrong. any returns True/False."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(all([1, 'x', [], 3]))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on order"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. [] is falsy, making all() False.",
      "1": "Correct. all() requires all elements truthy; [] is falsy.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. all evaluates deterministically."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Exceptions",
    "prompt": "Which statement about try/else is TRUE?",
    "options": [
      "else runs only if an exception happens",
      "else runs only if no exception happens",
      "else always runs",
      "else replaces finally"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That\u2019s the except block\u2019s job.",
      "1": "Correct. try/else executes else when no exception occurs.",
      "2": "Wrong. else is conditional on no exception.",
      "3": "Wrong. finally has a different role."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Exceptions",
    "prompt": "What happens?\n\ntry:\n    1/0\nfinally:\n    print('done')",
    "options": [
      "Prints done and continues normally",
      "Prints done then raises ZeroDivisionError",
      "Raises before printing",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The exception still occurs.",
      "1": "Correct. finally runs, then the exception propagates.",
      "2": "Wrong. finally prints before propagation.",
      "3": "Wrong. Syntax is valid."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Exceptions",
    "prompt": "Inside an except block, what does 'raise' with no arguments do?",
    "options": [
      "Raises SyntaxError",
      "Re-raises the current exception",
      "Raises None",
      "Suppresses the exception"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's legal syntax in an except block.",
      "1": "Correct. It re-raises the active exception.",
      "2": "Wrong. It doesn't raise None.",
      "3": "Wrong. It does the opposite of suppressing."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "IO",
    "prompt": "Which is TRUE about 'with open(...) as f:'?",
    "options": [
      "It disables buffering",
      "It always loads the file into memory",
      "It automatically closes even if errors happen",
      "It prevents exceptions"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Buffering behavior depends on mode and params.",
      "1": "Wrong. You still read explicitly.",
      "2": "Correct. Context manager closes file on exit.",
      "3": "Wrong. Exceptions can still occur."
    },
    "ikm_pdf_mapping": "Core Python File I/O"
  },
  {
    "topic": "IO",
    "prompt": "Which mode opens a file for appending text?",
    "options": [
      "'r'",
      "'w'",
      "'a'",
      "'rb'"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. 'r' is read mode.",
      "1": "Wrong. 'w' truncates and writes.",
      "2": "Correct. 'a' appends to the end.",
      "3": "Wrong. 'rb' is read-binary."
    },
    "ikm_pdf_mapping": "Core Python File I/O"
  },
  {
    "topic": "OOP",
    "prompt": "What does @staticmethod do?",
    "options": [
      "Passes instance as first arg",
      "Passes class as first arg",
      "No implicit first argument",
      "Makes method private"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That\u2019s normal instance methods.",
      "1": "Wrong. That\u2019s @classmethod.",
      "2": "Correct. staticmethod has no implicit self/cls.",
      "3": "Wrong. Python has no true private methods via decorator."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "What does @classmethod receive as its first argument?",
    "options": [
      "self",
      "cls",
      "both self and cls",
      "nothing"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. self is for instance methods.",
      "1": "Correct. cls is the class object.",
      "2": "Wrong. It receives only cls implicitly.",
      "3": "Wrong. It does receive cls."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "What is printed?\n\nclass A:\n    def f(self):\n        return 'A'\n\nclass B(A):\n    def f(self):\n        return super().f() + 'B'\n\nprint(B().f())",
    "options": [
      "A",
      "B",
      "AB",
      "BA"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. B overrides f and adds 'B'.",
      "1": "Wrong. It includes A's result too.",
      "2": "Correct. super().f() returns 'A', then + 'B' \u2192 'AB'.",
      "3": "Wrong. Order is A then B."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "If a class defines __len__ returning 0 and no __bool__, what is bool(obj)?",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends only on __bool__"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __len__ of 0 makes it falsy.",
      "1": "Correct. Python uses __len__ when __bool__ is absent.",
      "2": "Wrong. __len__ returning int is valid.",
      "3": "Wrong. __len__ also affects truthiness."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "Which special method enables obj[index]?",
    "options": [
      "__getitem__",
      "__getattr__",
      "__index__",
      "__slice__"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __getitem__ is used for indexing.",
      "1": "Wrong. __getattr__ handles missing attributes.",
      "2": "Wrong. __index__ is for converting an object to an integer index.",
      "3": "Wrong. __slice__ is not used like this in modern Python."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "Functional",
    "prompt": "What is the output?\n\nprint(list(map(lambda x: x*x, [1,2,3])))",
    "options": [
      "[1, 4, 9]",
      "[1, 2, 3]",
      "<map object ...>",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. map applies the function to each element.",
      "1": "Wrong. That would be identity function behavior.",
      "2": "Wrong. list(...) forces evaluation; without list it would show a map object.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Functional",
    "prompt": "What does this print?\n\nprint(list(filter(None, [0, 1, '', 'a'])))",
    "options": [
      "[0, 1, '', 'a']",
      "[1, 'a']",
      "['a']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. filter(None, ...) removes falsy values.",
      "1": "Correct. 0 and '' are falsy; 1 and 'a' remain.",
      "2": "Wrong. 1 is also truthy so it remains too.",
      "3": "Wrong. This is valid usage."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Dicts",
    "prompt": "What is the output?\n\nx = {'a': 1, 'b': 2}\nprint(list(x))",
    "options": [
      "['a', 'b'] (in insertion order)",
      "['a', 1, 'b', 2]",
      "[('a',1), ('b',2)]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Iterating a dict yields its keys (in insertion order in modern Python).",
      "1": "Wrong. Iteration does not yield values inline.",
      "2": "Wrong. That would be list(x.items()).",
      "3": "Wrong. list(dict) is valid."
    },
    "ikm_pdf_mapping": "Python Dictionaries"
  },
  {
    "topic": "Concurrency",
    "prompt": "Which is TRUE about the Python's Global Interpreter Lock (GIL) in CPython?",
    "options": [
      "It prevents I/O concurrency entirely",
      "It prevents true parallel execution of CPU-bound Python bytecode in threads",
      "It prevents multiprocessing from using multiple cores",
      "It makes asyncio impossible"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. I/O-bound threads can still overlap while waiting on I/O.",
      "1": "Correct. CPU-bound threads won\u2019t run Python bytecode in true parallel. (GIL) is a mutex that ensures only one thread executes Python bytecode at a time in CPython, the standard Python implementation.",
      "2": "Wrong. multiprocessing uses separate processes and can use multiple cores.",
      "3": "Wrong. asyncio is cooperative and works fine."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Concurrency",
    "prompt": "What does 'await' require on the right-hand side?",
    "options": [
      "A normal function",
      "An awaitable (coroutine/future/task)",
      "Only a generator",
      "A thread object"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Normal functions return values immediately; not awaitable.",
      "1": "Correct. await works with awaitables.",
      "2": "Wrong. Generators are not awaitables unless wrapped/converted.",
      "3": "Wrong. Threads are not awaitables by default."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Typing",
    "prompt": "typing.Optional[int] means:",
    "options": [
      "int only",
      "int or None",
      "any type",
      "a required int"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Optional allows None.",
      "1": "Correct. Optional[int] == Union[int, None].",
      "2": "Wrong. That would be Any.",
      "3": "Wrong. Optional is the opposite of required-only."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\ns = 'abc'\ntry:\n    s[0] = 'z'\nexcept Exception as e:\n    print(type(e).__name__)",
    "options": [
      "ValueError",
      "TypeError",
      "IndexError",
      "No output"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Not a ValueError.",
      "1": "Correct. Strings are immutable; item assignment raises TypeError.",
      "2": "Wrong. Index 0 is valid; immutability is the issue.",
      "3": "Wrong. The exception is caught and printed."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nprint([1,2] == [1,2], [1,2] is [1,2])",
    "options": [
      "True True",
      "True False",
      "False True",
      "False False"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Separate list literals are different objects \u2192 'is' is False.",
      "1": "Correct. Values equal, identities differ.",
      "2": "Wrong. Equality is True here.",
      "3": "Wrong. Equality is True."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "Dicts",
    "prompt": "Which statement about dict membership is TRUE?\n\n('x' in {'x': 1})",
    "options": [
      "Checks values for membership",
      "Checks keys for membership",
      "Raises TypeError",
      "Depends on hash seed"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 'in' on a dict checks keys, not values.",
      "1": "Correct. Dict membership tests keys.",
      "2": "Wrong. It's valid.",
      "3": "Wrong. Meaning is deterministic; hash seed doesn't change correctness."
    },
    "ikm_pdf_mapping": "Python Dictionaries"
  },
  {
    "topic": "Decorators",
    "prompt": "What does this print?\n\ndef deco(f):\n    def wrapper(*a, **k):\n        return f(*a, **k) + 1\n    return wrapper\n\n@deco\ndef f():\n    return 10\n\nprint(f())",
    "options": [
      "10",
      "11",
      "TypeError",
      "wrapper"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The decorator modifies the function result.",
      "1": "Correct. wrapper calls f() (10) then adds 1.",
      "2": "Wrong. All operations are valid.",
      "3": "Wrong. It prints the return value, not the function object."
    },
    "ikm_pdf_mapping": "Python Formatting and Decorators"
  },
  {
    "topic": "Closures",
    "prompt": "What does this print?\n\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda: i)\n\nprint([f() for f in funcs])",
    "options": [
      "[0, 1, 2]",
      "[2, 2, 2]",
      "[3, 3, 3]",
      "Raises NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Late binding means lambdas read i when called, not when created.",
      "1": "Correct. i ends at 2, so all lambdas return 2.",
      "2": "Wrong. range(3) ends with i == 2.",
      "3": "Wrong. i exists in the enclosing scope at call time."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Closures",
    "prompt": "How do you fix the late-binding issue in the previous code (best answer)?",
    "options": [
      "Use lambda i=i: i",
      "Use global i",
      "Convert i to str",
      "Use nonlocal i"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Default args capture the current value at definition time.",
      "1": "Wrong. global doesn't capture per-iteration values.",
      "2": "Wrong. Type conversion doesn't address binding.",
      "3": "Wrong. nonlocal is for assigning into enclosing scopes, not capturing loop values."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Context Managers",
    "prompt": "What does this print?\n\nclass C:\n    def __enter__(self):\n        print('enter')\n        return 123\n    def __exit__(self, exc_type, exc, tb):\n        print('exit')\n        return True\n\nwith C() as x:\n    print(x)\n    1/0\nprint('after')",
    "options": [
      "enter\n123\nexit\nafter",
      "enter\n123\nexit",
      "enter\n123 then ZeroDivisionError",
      "enter\nexit then ZeroDivisionError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __exit__ returns True which suppresses the exception, then execution continues.",
      "1": "Wrong. It continues to print 'after' because exception is suppressed.",
      "2": "Wrong. Exception is suppressed due to return True in __exit__.",
      "3": "Wrong. The body prints x before the exception occurs."
    },
    "ikm_pdf_mapping": "Core Python File I/O"
  },
  {
    "topic": "Iteration Protocol",
    "prompt": "Which statement is TRUE about iterators?",
    "options": [
      "Every iterable is an iterator",
      "An iterator must implement __iter__ and __next__",
      "__iter__ must return a new independent iterator each time",
      "Iterators can be restarted by calling iter(it)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Iterables produce iterators; they aren't necessarily iterators themselves.",
      "1": "Correct. That's the core iterator protocol.",
      "2": "Wrong. That's typical for iterables; iterators usually return themselves from __iter__.",
      "3": "Wrong. Most iterators are one-shot and cannot be restarted."
    },
    "ikm_pdf_mapping": "Python Generators and Coroutines"
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this produce?\n\n{x: x*x for x in [1,1,2]}",
    "options": [
      "{1: 1, 2: 4} (last wins)",
      "{1: 1, 1: 1, 2: 4}",
      "{1: 1, 2: 2}",
      "Raises ValueError for duplicate keys"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Dict keys are unique; later assignments overwrite earlier ones.",
      "1": "Wrong. Dicts cannot contain duplicate keys.",
      "2": "Wrong. Value for 2 should be 4.",
      "3": "Wrong. No error is raised."
    },
    "ikm_pdf_mapping": "Python Comprehensions"
  },
  {
    "topic": "Dataclasses",
    "prompt": "What is TRUE about a frozen dataclass?",
    "options": [
      "It prevents rebinding of all variables",
      "It prevents attribute assignment (like immutability) after creation",
      "It deep-freezes nested mutable fields",
      "It cannot have default values"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It only affects dataclass instance attribute assignment, not variables outside.",
      "1": "Correct. Frozen prevents setting attributes after init.",
      "2": "Wrong. Nested objects can still be mutated if they are mutable.",
      "3": "Wrong. Frozen dataclasses can still have defaults."
    },
    "ikm_pdf_mapping": "Python Classes"
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    raise ValueError('x')\nexcept Exception as e:\n    print(type(e).__name__)\nelse:\n    print('else')\nfinally:\n    print('finally')",
    "options": [
      "ValueError\nfinally",
      "Exception\nelse\nfinally",
      "ValueError\nelse\nfinally",
      "ValueError only"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. except runs, else does not, finally always runs.",
      "1": "Wrong. The exception type printed is ValueError, not Exception.",
      "2": "Wrong. else doesn't run when an exception occurs.",
      "3": "Wrong. finally always runs."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Imports",
    "prompt": "Which is TRUE about `import module` vs `from module import name`?",
    "options": [
      "They are identical in all cases",
      "`from module import name` binds `name` directly in the importing namespace",
      "`import module` binds all module attributes into globals",
      "`from module import name` prevents module code from executing"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. They bind different names in the importing scope.",
      "1": "Correct. The imported name is bound directly (no module prefix needed).",
      "2": "Wrong. `import module` binds the module object only.",
      "3": "Wrong. Module code still executes on first import."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Async",
    "prompt": "What does `await` require?",
    "options": [
      "A regular function",
      "An awaitable (coroutine/future/task)",
      "A generator expression",
      "A thread object"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Regular functions are not awaitable.",
      "1": "Correct. await works with awaitables.",
      "2": "Wrong. Generators are not awaitables unless adapted.",
      "3": "Wrong. Threads are not awaitables by default."
    },
    "ikm_pdf_mapping": "Python Generators and Coroutines / Python Concurrency"
  },
  {
    "topic": "GIL",
    "prompt": "Which statement best describes the CPython GIL?",
    "options": [
      "Threads cannot be used at all",
      "Threads cannot run CPU-bound Python bytecode in true parallel",
      "Multiprocessing is also limited to one core",
      "Asyncio bypasses the GIL for CPU work"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Threads can be useful for I/O-bound workloads.",
      "1": "Correct. CPU-bound work doesn't gain true parallelism in threads under CPython.",
      "2": "Wrong. Multiprocessing uses multiple processes and can use multiple cores.",
      "3": "Wrong. Asyncio is cooperative; CPU work still blocks unless offloaded."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Mutability",
    "prompt": "What does this print?\n\na = ([],)\na[0].append(1)\nprint(a)",
    "options": [
      "TypeError because tuple is immutable",
      "([],)",
      "([1],)",
      "Raises AttributeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. The tuple can't be rebound, but the list inside can be mutated.",
      "1": "Wrong. The list was appended to.",
      "2": "Correct. The list inside the tuple becomes [1].",
      "3": "Wrong. list.append exists."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Descriptors",
    "prompt": "Which mechanism powers `@property`?",
    "options": [
      "Metaclasses only",
      "Descriptors (__get__/__set__)",
      "Monkey patching",
      "The GIL"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Metaclasses are not required for property.",
      "1": "Correct. property implements the descriptor protocol.",
      "2": "Wrong. Monkey patching is unrelated.",
      "3": "Wrong. The GIL is unrelated."
    },
    "ikm_pdf_mapping": "Python Classes / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    x = 1\n\nclass B(A):\n    x = 2\n\nprint(A.x, B.x, B().x)",
    "options": [
      "1 1 1",
      "1 2 2",
      "2 2 1",
      "2 1 2"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. B overrides x.",
      "1": "Correct. A.x=1, B.x=2, instance finds B.x=2.",
      "2": "Wrong. A.x stays 1.",
      "3": "Wrong. A.x is not 2."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "Hashing",
    "prompt": "Why can a tuple be used as a dict key but a list cannot (in general)?",
    "options": [
      "Tuples are faster",
      "Lists are ordered",
      "Tuples are (generally) immutable and hashable; lists are mutable and unhashable",
      "Lists cannot contain strings"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Speed isn't the rule for hashability.",
      "1": "Wrong. Both are ordered sequences.",
      "2": "Correct. Mutability breaks hash invariants.",
      "3": "Wrong. Lists can contain strings."
    },
    "ikm_pdf_mapping": "Python Dictionaries"
  },
  {
    "topic": "Typing",
    "prompt": "What does Optional[int] mean?",
    "options": [
      "int only",
      "int or None",
      "any type",
      "a required int"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Optional includes None.",
      "1": "Correct. Optional[int] == Union[int, None].",
      "2": "Wrong. That would be Any.",
      "3": "Wrong. Optional suggests it can be None."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Functional",
    "prompt": "What does this print?\n\nprint(list(filter(None, [0, 1, '', 'a', None])))",
    "options": [
      "[0, 1, '', 'a', None]",
      "[1, 'a']",
      "['a']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. filter(None, ...) removes falsy values.",
      "1": "Correct. Keeps truthy values: 1 and 'a'.",
      "2": "Wrong. 1 is also truthy.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Evaluation Order",
    "prompt": "What does this print?\n\nx = 0\nx = x + 1 if True else x + 100\nprint(x)",
    "options": [
      "0",
      "1",
      "100",
      "101"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The conditional expression takes the True branch.",
      "1": "Correct. True branch evaluates to x+1 (0+1).",
      "2": "Wrong. Else branch is not evaluated.",
      "3": "Wrong. Only one branch is evaluated."
    },
    "ikm_pdf_mapping": "Python Precedence and Associativity"
  },
  {
    "topic": "Stdlib",
    "prompt": "What is the output?\n\nimport math\nprint(math.isclose(0.1 + 0.2, 0.3))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. isclose checks approximate equality with tolerances.",
      "1": "Wrong. isclose is designed for floating-point comparisons.",
      "2": "Wrong. This is valid usage.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Performance",
    "prompt": "Which is generally more memory-efficient for large sequences?",
    "options": [
      "List comprehension",
      "Generator expression",
      "Building a list then iterating",
      "Converting to tuple first"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Lists materialize all items immediately.",
      "1": "Correct. Generators produce items lazily.",
      "2": "Wrong. It creates the whole list in memory.",
      "3": "Wrong. Tuples still store all items."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "MRO",
    "prompt": "What determines method resolution order (MRO) in Python?",
    "options": [
      "Depth-first search",
      "Breadth-first search",
      "C3 linearization",
      "Order of class definition"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python does not use naive depth-first search.",
      "1": "Wrong. Breadth-first alone is insufficient.",
      "2": "Correct. Python uses C3 linearization for MRO.",
      "3": "Wrong. Definition order alone is not sufficient."
    },
    "ikm_pdf_mapping": "Python Inheritance"
  },
  {
    "topic": "MRO",
    "prompt": "What does this print?\n\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass\n\nprint(D.__mro__)",
    "options": [
      "(D, B, C, A, object)",
      "(D, C, B, A, object)",
      "(D, B, A, C, object)",
      "Raises TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. This follows C3 linearization.",
      "1": "Wrong. Order of bases is respected.",
      "2": "Wrong. A must come after both B and C.",
      "3": "Wrong. This hierarchy is valid."
    },
    "ikm_pdf_mapping": "Python Inheritance"
  },
  {
    "topic": "Descriptors",
    "prompt": "Which methods define the descriptor protocol?",
    "options": [
      "__get__ only",
      "__get__ and __set__",
      "__get__, __set__, and __delete__",
      "__call__"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Descriptors can define more than __get__.",
      "1": "Wrong. __delete__ is also part of the protocol.",
      "2": "Correct. These three define descriptor behavior.",
      "3": "Wrong. __call__ is unrelated."
    },
    "ikm_pdf_mapping": "Python Classes / Python Encapsulation"
  },
  {
    "topic": "Descriptors",
    "prompt": "Which built-in feature relies on descriptors?",
    "options": [
      "for loops",
      "@property",
      "lambda",
      "try/except"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Iteration does not use descriptors.",
      "1": "Correct. property is implemented using descriptors.",
      "2": "Wrong. Lambdas are functions.",
      "3": "Wrong. Exception handling is unrelated."
    },
    "ikm_pdf_mapping": "Python Classes / Python Encapsulation"
  },
  {
    "topic": "Weak References",
    "prompt": "What is the purpose of weakref?",
    "options": [
      "Improve performance",
      "Prevent garbage collection",
      "Reference objects without preventing GC",
      "Make objects immutable"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. weakref is about lifecycle, not speed.",
      "1": "Wrong. weak references do not prevent GC.",
      "2": "Correct. weakref allows GC when no strong refs exist.",
      "3": "Wrong. It does not affect mutability."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Garbage Collection",
    "prompt": "What does reference counting fail to handle without GC?",
    "options": [
      "Large objects",
      "Immutable objects",
      "Circular references",
      "Function calls"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Size is irrelevant.",
      "1": "Wrong. Immutability does not affect reference counting.",
      "2": "Correct. Cycles require cyclic garbage collection.",
      "3": "Wrong. Calls do not cause leaks."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Contextlib",
    "prompt": "What does @contextmanager allow you to do?",
    "options": [
      "Create decorators",
      "Create generators",
      "Create context managers using yield",
      "Suppress exceptions globally"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. contextmanager is not for decorators in general.",
      "1": "Wrong. Though it uses yield, its purpose is context management.",
      "2": "Correct. yield splits enter and exit logic.",
      "3": "Wrong. Exception suppression is optional."
    },
    "ikm_pdf_mapping": "Core Python File I/O"
  },
  {
    "topic": "Contextlib",
    "prompt": "If a contextmanager generator does not yield, what happens?",
    "options": [
      "Nothing",
      "RuntimeError",
      "StopIteration",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The context requires a yield.",
      "1": "Correct. A RuntimeError is raised.",
      "2": "Wrong. StopIteration is internal.",
      "3": "Wrong. Syntax is valid."
    },
    "ikm_pdf_mapping": "Core Python File I/O"
  },
  {
    "topic": "Functools",
    "prompt": "What does functools.lru_cache do?",
    "options": [
      "Caches results of function calls",
      "Caches function bytecode",
      "Optimizes recursion only",
      "Makes functions thread-safe"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Results are memoized based on arguments.",
      "1": "Wrong. Bytecode is not cached this way.",
      "2": "Wrong. It works for any function.",
      "3": "Wrong. Thread safety is not guaranteed."
    },
    "ikm_pdf_mapping": "Python Formatting and Decorators"
  },
  {
    "topic": "Functools",
    "prompt": "What happens when lru_cache reaches maxsize?",
    "options": [
      "Cache clears entirely",
      "Oldest entries are evicted",
      "Newest entries are evicted",
      "Raises MemoryError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Cache is not fully cleared.",
      "1": "Correct. Least recently used entries are evicted.",
      "2": "Wrong. New entries are retained.",
      "3": "Wrong. Eviction prevents memory errors."
    },
    "ikm_pdf_mapping": "Python Formatting and Decorators"
  },
  {
    "topic": "Itertools",
    "prompt": "Which itertools function groups consecutive items?",
    "options": [
      "groupby",
      "combinations",
      "product",
      "chain"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. groupby groups adjacent elements.",
      "1": "Wrong. combinations creates tuples.",
      "2": "Wrong. product computes Cartesian products.",
      "3": "Wrong. chain concatenates iterables."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.count() produce?",
    "options": [
      "A finite range",
      "An infinite iterator",
      "A list",
      "Raises StopIteration"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. count is unbounded.",
      "1": "Correct. It produces an infinite sequence.",
      "2": "Wrong. It yields values lazily.",
      "3": "Wrong. It never stops."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Memory",
    "prompt": "Which object typically uses the least memory?",
    "options": [
      "List",
      "Tuple",
      "Set",
      "Dict"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Lists have extra capacity overhead.",
      "1": "Correct. Tuples are compact and immutable.",
      "2": "Wrong. Sets require hashing overhead.",
      "3": "Wrong. Dicts store key-value pairs."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "CPython Internals",
    "prompt": "What is Python bytecode?",
    "options": [
      "Machine code",
      "Intermediate representation executed by the VM",
      "Assembly language",
      "Source code"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Bytecode is not machine code.",
      "1": "Correct. Bytecode is run by the Python virtual machine.",
      "2": "Wrong. Assembly is lower-level.",
      "3": "Wrong. Bytecode is compiled from source."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Asyncio",
    "prompt": "What is the primary purpose of the asyncio event loop?",
    "options": [
      "Run threads in parallel",
      "Schedule and run asynchronous tasks",
      "Replace the operating system scheduler",
      "Execute CPU-bound code faster"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. asyncio does not manage OS threads.",
      "1": "Correct. The event loop schedules and runs async tasks cooperatively.",
      "2": "Wrong. The OS scheduler is unchanged.",
      "3": "Wrong. Asyncio does not speed up CPU-bound work."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Asyncio",
    "prompt": "What happens if you call an async function without awaiting it?",
    "options": [
      "It runs immediately",
      "It raises a SyntaxError",
      "It returns a coroutine object",
      "It blocks the event loop"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Async functions do not execute until awaited.",
      "1": "Wrong. This is syntactically valid.",
      "2": "Correct. Calling returns a coroutine object.",
      "3": "Wrong. Nothing runs yet."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Asyncio",
    "prompt": "Which function is used to run the asyncio event loop in Python 3.7+?",
    "options": [
      "loop.run()",
      "asyncio.execute()",
      "asyncio.run()",
      "asyncio.start()"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. loop.run is not the public API.",
      "1": "Wrong. This function does not exist.",
      "2": "Correct. asyncio.run() is the recommended entry point.",
      "3": "Wrong. This function does not exist."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Typing",
    "prompt": "What does typing.Protocol enable?",
    "options": [
      "Runtime type enforcement",
      "Nominal subtyping",
      "Structural subtyping",
      "Duck typing removal"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Protocols are for static typing.",
      "1": "Wrong. Protocols avoid nominal inheritance.",
      "2": "Correct. Protocols enable structural (duck-typed) subtyping.",
      "3": "Wrong. Protocols formalize duck typing."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Typing",
    "prompt": "What is the runtime effect of type hints?",
    "options": [
      "They enforce types automatically",
      "They slow down execution",
      "They are mostly ignored at runtime",
      "They prevent invalid assignments"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Python does not enforce types by default.",
      "1": "Wrong. They usually have no runtime cost.",
      "2": "Correct. Type hints are for tooling, not enforcement.",
      "3": "Wrong. Invalid assignments are still allowed."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Metaclasses",
    "prompt": "When is a metaclass __new__ method executed?",
    "options": [
      "When an instance is created",
      "When a class is defined",
      "When a module is imported",
      "When __init__ is called"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Instance creation is handled later.",
      "1": "Correct. Metaclasses control class creation.",
      "2": "Wrong. Imports may trigger class definition, but not always.",
      "3": "Wrong. __init__ refers to instances."
    },
    "ikm_pdf_mapping": "Python Classes"
  },
  {
    "topic": "Metaclasses",
    "prompt": "Which keyword argument is passed to a metaclass __new__?",
    "options": [
      "self",
      "cls",
      "bases",
      "locals"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. self is for instances.",
      "1": "Wrong. cls refers to the metaclass itself.",
      "2": "Correct. bases contains base classes of the new class.",
      "3": "Wrong. locals are passed as a dict, not as this name."
    },
    "ikm_pdf_mapping": "Python Classes"
  },
  {
    "topic": "Imports",
    "prompt": "Where are imported modules cached?",
    "options": [
      "globals()",
      "builtins",
      "sys.modules",
      "__all__"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. globals only affect the current module.",
      "1": "Wrong. builtins is separate.",
      "2": "Correct. sys.modules caches loaded modules.",
      "3": "Wrong. __all__ controls export behavior."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Imports",
    "prompt": "What happens if you delete an entry from sys.modules?",
    "options": [
      "The module is unloaded from memory",
      "The module cannot be imported again",
      "The next import reloads the module",
      "Python crashes"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Other references may still exist.",
      "1": "Wrong. It can be re-imported.",
      "2": "Correct. The next import reloads the module.",
      "3": "Wrong. This is safe (though advanced)."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Multiprocessing",
    "prompt": "Why does multiprocessing bypass the GIL?",
    "options": [
      "It disables the GIL",
      "Each process has its own interpreter",
      "It rewrites Python bytecode",
      "It uses async IO"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The GIL still exists per process.",
      "1": "Correct. Each process has its own GIL.",
      "2": "Wrong. Bytecode is unchanged.",
      "3": "Wrong. Async IO is unrelated."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Multiprocessing",
    "prompt": "What must be true for objects sent between processes?",
    "options": [
      "They must be hashable",
      "They must be immutable",
      "They must be picklable",
      "They must be threadsafe"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Hashability is irrelevant.",
      "1": "Wrong. Mutable objects can be pickled.",
      "2": "Correct. Objects are serialized via pickle.",
      "3": "Wrong. Thread safety is unrelated."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Collections",
    "prompt": "What does collections.defaultdict provide?",
    "options": [
      "Automatic key deletion",
      "Default values for missing keys",
      "Thread safety",
      "Ordered iteration"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Keys are not deleted.",
      "1": "Correct. Missing keys are created automatically.",
      "2": "Wrong. defaultdict is not thread-safe.",
      "3": "Wrong. Order depends on insertion."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Collections",
    "prompt": "What does collections.deque provide over list?",
    "options": [
      "Faster random access",
      "Efficient appends and pops from both ends",
      "Automatic sorting",
      "Lower memory usage in all cases"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Deque is not optimized for random access.",
      "1": "Correct. Deque is optimized for both ends.",
      "2": "Wrong. Deque does not sort.",
      "3": "Wrong. Memory usage varies."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Evaluation",
    "prompt": "What does short-circuit evaluation mean?",
    "options": [
      "Expressions are evaluated faster",
      "Later operands may not be evaluated",
      "Evaluation happens in parallel",
      "Exceptions are suppressed"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Speed is not guaranteed.",
      "1": "Correct. Logical operators may skip evaluation.",
      "2": "Wrong. Evaluation is sequential.",
      "3": "Wrong. Exceptions are not suppressed."
    },
    "ikm_pdf_mapping": "Python Precedence and Associativity"
  },
  {
    "topic": "Evaluation",
    "prompt": "What does this print?\n\nprint(False and (1/0))",
    "options": [
      "False",
      "ZeroDivisionError",
      "None",
      "True"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. The second operand is never evaluated.",
      "1": "Wrong. Short-circuit prevents evaluation.",
      "2": "Wrong. The result is False.",
      "3": "Wrong. False and anything is False."
    },
    "ikm_pdf_mapping": "Python Precedence and Associativity"
  },
  {
    "topic": "Performance",
    "prompt": "Which is typically the fastest membership test?",
    "options": [
      "x in list",
      "x in tuple",
      "x in set",
      "x in string"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. List membership is O(n).",
      "1": "Wrong. Tuple membership is O(n).",
      "2": "Correct. Set membership is O(1) average case.",
      "3": "Wrong. Strings require scanning."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Security",
    "prompt": "Why is eval() dangerous?",
    "options": [
      "It is slow",
      "It cannot evaluate expressions",
      "It can execute arbitrary code",
      "It leaks memory"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Speed is not the primary risk.",
      "1": "Wrong. eval can evaluate expressions.",
      "2": "Correct. eval executes arbitrary code.",
      "3": "Wrong. Memory leaks are not the main concern."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Security",
    "prompt": "Which is safer than eval for parsing literals?",
    "options": [
      "exec",
      "compile",
      "ast.literal_eval",
      "globals"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. exec is also dangerous.",
      "1": "Wrong. compile does not restrict execution.",
      "2": "Correct. literal_eval safely parses literals only.",
      "3": "Wrong. globals exposes namespace."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(7 // 2)",
    "options": [
      "3.5",
      "3",
      "4",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's true division.",
      "1": "Correct. // is floor division, so 7//2 is 3.",
      "2": "Wrong. Floor division rounds down.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint(7 % 2)",
    "options": [
      "0",
      "1",
      "2",
      "3"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 7 isn't divisible by 2.",
      "1": "Correct. 7 mod 2 is 1.",
      "2": "Wrong. That's the divisor.",
      "3": "Wrong. That's too large for a remainder."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What is the output?\n\nprint(type(True))",
    "options": [
      "<class 'bool'>",
      "<class 'int'>",
      "<class 'str'>",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. True is a bool.",
      "1": "Wrong. bool is a distinct type (though it's a subclass of int).",
      "2": "Wrong. It's not a string.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(2 ** 3 ** 2)",
    "options": [
      "512",
      "64",
      "16",
      "SyntaxError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. ** is right-associative: 2 ** (3 ** 2) = 2 ** 9 = 512.",
      "1": "Wrong. That's (2**3)**2.",
      "2": "Wrong. That's 2**4.",
      "3": "Wrong. This is valid syntax."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint('py' + 'thon')",
    "options": [
      "python",
      "python",
      "py thon",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Case/spacing matters.",
      "1": "Correct. String concatenation joins them with no extra characters.",
      "2": "Wrong. No space is inserted automatically.",
      "3": "Wrong. Concatenation of str is valid."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint('a' * 3)",
    "options": [
      "aaa",
      "a3",
      "'aaa'",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Repetition with * repeats the string.",
      "1": "Wrong. It repeats, it doesn't append the number.",
      "2": "Wrong. print shows the value, not repr with quotes.",
      "3": "Wrong. str * int is valid."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint(None is None)",
    "options": [
      "True",
      "False",
      "Depends on version",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. None is a singleton; identity comparison is True.",
      "1": "Wrong. There is only one None object.",
      "2": "Wrong. This is consistent.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(bool(''))",
    "options": [
      "True",
      "False",
      "None",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Non-empty strings are truthy; empty is falsy.",
      "1": "Correct. Empty string is falsy.",
      "2": "Wrong. bool returns True/False.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(int('010'))",
    "options": [
      "10",
      "8",
      "Raises ValueError",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. int() parses base-10 by default unless base is provided.",
      "1": "Wrong. Octal requires base=8 or 0o prefix.",
      "2": "Wrong. '010' is valid decimal.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(type(3//2))",
    "options": [
      "<class 'float'>",
      "<class 'int'>",
      "<class 'bool'>",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's for /.",
      "1": "Correct. Floor division of ints produces an int.",
      "2": "Wrong. It's an int, not bool.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint(bool({}))",
    "options": [
      "True",
      "False",
      "TypeError",
      "None"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Only non-empty containers are truthy.",
      "1": "Correct. An empty dict is falsy.",
      "2": "Wrong. bool({}) is valid.",
      "3": "Wrong. bool returns True/False."
    },
    "ikm_pdf_mapping": "Python Control Flow"
  },
  {
    "topic": "Truthiness",
    "prompt": "What does this print?\n\nprint([] == False)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Equality isn't the same as truthiness.",
      "1": "Correct. [] is falsy, but it is not equal to False.",
      "2": "Wrong. Comparison is allowed.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Control Flow"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(1 < 2 < 3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Chained comparisons work: 1<2 and 2<3.",
      "1": "Wrong. Both comparisons are True.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(1 < 2 > 3)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 2 is not > 3.",
      "1": "Correct. It's (1<2) and (2>3); second part is False.",
      "2": "Wrong. Valid syntax.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Truthiness",
    "prompt": "Which are falsy? (Select ALL that apply)",
    "options": [
      "set()",
      "{0}",
      "0.0",
      "'False'"
    ],
    "correct": [
      0,
      2
    ],
    "explanations": {
      "0": "Correct. Empty set is falsy.",
      "1": "Wrong. Non-empty set is truthy.",
      "2": "Correct. 0.0 is falsy (numeric zero).",
      "3": "Wrong. Non-empty strings are truthy."
    },
    "ikm_pdf_mapping": "Python Control Flow"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint('5' == 5)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. '5' is a str.",
      "1": "Correct. Different types; no implicit conversion for ==.",
      "2": "Wrong. Comparing different types is allowed; it just returns False.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint('5' + str(5))",
    "options": [
      "10",
      "55",
      "'55'",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's numeric addition, not string concatenation.",
      "1": "Correct. '5' + '5' becomes '55'.",
      "2": "Wrong. print doesn't add quotes.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(5 == 5.0)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. int and float compare by numeric value; 5 == 5.0 is True.",
      "1": "Wrong. They are numerically equal.",
      "2": "Wrong. Comparison is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What does this print?\n\nprint(5 is 5)",
    "options": [
      "Always True",
      "Always False",
      "Implementation detail; don't rely on it",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Not guaranteed.",
      "1": "Wrong. It can be True in CPython for small ints.",
      "2": "Correct. Small integer interning can make this True, but it's not guaranteed by the language spec.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Basics",
    "prompt": "What is printed?\n\nprint(5/2, 5//2)",
    "options": [
      "2.5 2",
      "2 2.5",
      "2.0 2",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. / gives 2.5, // gives 2.",
      "1": "Wrong. Order is / then //.",
      "2": "Wrong. 5/2 is 2.5 not 2.0.",
      "3": "Wrong. No exception."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({1,2,3} & {2,3,4})",
    "options": [
      "{1}",
      "{2, 3}",
      "{4}",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's the difference.",
      "1": "Correct. & is set intersection.",
      "2": "Wrong. 4 isn't in both sets.",
      "3": "Wrong. Set intersection is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nd = {'a': 1}\nd['b'] = 2\nprint(d['b'])",
    "options": [
      "1",
      "2",
      "KeyError",
      "None"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's d['a'].",
      "1": "Correct. After assignment, d['b'] is 2.",
      "2": "Wrong. The key exists.",
      "3": "Wrong. Direct indexing returns the value, not None."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint(len({'a':1, 'a':2}))",
    "options": [
      "1",
      "2",
      "Raises ValueError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Duplicate keys overwrite; only one key remains.",
      "1": "Wrong. Dict keys are unique; duplicates collapse.",
      "2": "Wrong. No error; last assignment wins.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint(list({'a':1, 'b':2}.values()))",
    "options": [
      "['a','b']",
      "[1, 2]",
      "[('a',1),('b',2)]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's keys.",
      "1": "Correct. .values() yields the values.",
      "2": "Wrong. That's items().",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint([1,2,3][-1])",
    "options": [
      "1",
      "2",
      "3",
      "IndexError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. That's first element.",
      "1": "Wrong. That's middle element.",
      "2": "Correct. -1 indexes the last element.",
      "3": "Wrong. -1 is valid index."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = [1,2,3]\nx.pop()\nprint(x)",
    "options": [
      "[1,2,3]",
      "[1,2]",
      "[2,3]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. pop mutates the list.",
      "1": "Correct. pop() removes and returns the last element.",
      "2": "Wrong. It removes from the end by default.",
      "3": "Wrong. pop() is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = [1,2,3]\nprint(x.pop(0), x)",
    "options": [
      "1 [2, 3]",
      "3 [1, 2]",
      "1 [1, 2]",
      "IndexError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. pop(0) removes the first element and returns it.",
      "1": "Wrong. pop(0) targets index 0, not the end.",
      "2": "Wrong. It removes the element, it doesn't keep it.",
      "3": "Wrong. Index 0 exists."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "Which are valid ways to create an empty set? (Select ALL that apply)",
    "options": [
      "{}",
      "set()",
      "{1,2}",
      "{ }"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. {} creates an empty dict, not a set.",
      "1": "Correct. set() creates an empty set.",
      "2": "Wrong. This is a non-empty set.",
      "3": "Wrong. { } is the same as {}, an empty dict."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint(tuple([1,2,3]))",
    "options": [
      "[1, 2, 3]",
      "(1, 2, 3)",
      "{1, 2, 3}",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's still a list.",
      "1": "Correct. tuple(...) converts the list into a tuple.",
      "2": "Wrong. That's a set literal.",
      "3": "Wrong. This conversion is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({} == dict())",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Both create empty dicts.",
      "1": "Wrong. They are equal.",
      "2": "Wrong. Comparison is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = {'a': 1}\ny = x.copy()\nx['a'] = 99\nprint(y['a'])",
    "options": [
      "99",
      "1",
      "KeyError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y is a separate dict.",
      "1": "Correct. copy() makes a shallow copy of the dict, so y keeps the old value for that key.",
      "2": "Wrong. Key exists in y.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nx = {'a': []}\ny = x.copy()\nx['a'].append(1)\nprint(y['a'])",
    "options": [
      "[]",
      "[1]",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. The shared list was mutated.",
      "1": "Correct. copy() is shallow; both dicts share the same inner list.",
      "2": "Wrong. append is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({1,2,3} - {2})",
    "options": [
      "{1, 2}",
      "{1, 3}",
      "{2, 3}",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 2 is removed, not kept.",
      "1": "Correct. - is set difference: remove elements in the right set.",
      "2": "Wrong. 2 is removed.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Data Structures",
    "prompt": "What does this print?\n\nprint({1,2} | {2,3})",
    "options": [
      "{1, 2}",
      "{2, 3}",
      "{1, 2, 3}",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. Union includes 3.",
      "1": "Wrong. Union includes 1.",
      "2": "Correct. | is set union.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples / Python Dictionaries"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'.upper())",
    "options": [
      "ABC",
      "Abc",
      "abc",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. upper() returns an uppercase copy.",
      "1": "Wrong. uppercases all letters.",
      "2": "Wrong. It changes case.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'.find('d'))",
    "options": [
      "-1",
      "0",
      "1",
      "Raises ValueError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. find returns -1 when not found.",
      "1": "Wrong. 0 would mean found at start.",
      "2": "Wrong. 1 would mean found at index 1.",
      "3": "Wrong. find does not raise; index() would."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a,b,c'.split(','))",
    "options": [
      "['a','b','c']",
      "['a', 'b', 'c']",
      "a,b,c",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. print shows spaces after commas in list repr.",
      "1": "Correct. split returns a list of strings.",
      "2": "Wrong. split produces a list.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "What does this print?\n\nprint(b'hi' + b'!')",
    "options": [
      "b'hi!'",
      "'hi!'",
      "hi!",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Bytes concatenate to bytes.",
      "1": "Wrong. It's bytes, not str.",
      "2": "Wrong. print shows b'' for bytes.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings/Bytes",
    "prompt": "What converts str to bytes using UTF-8?",
    "options": [
      "s.decode('utf-8')",
      "s.encode('utf-8')",
      "bytes(s)",
      "str(s)"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. decode is for bytes -> str.",
      "1": "Correct. encode converts str -> bytes.",
      "2": "Wrong. bytes(s) requires an encoding unless s is already bytes.",
      "3": "Wrong. str(s) stays a str."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint(f\"{3.14159:.2f}\")",
    "options": [
      "3.14",
      "3.14159",
      "3.15",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. :.2f formats to 2 decimal places (rounded).",
      "1": "Wrong. Formatting rounds/truncates to 2 decimals.",
      "2": "Wrong. 3.14159 rounds to 3.14, not 3.15.",
      "3": "Wrong. f-strings are valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('hello'.replace('l','L', 1))",
    "options": [
      "heLlo",
      "heLLo",
      "heLLO",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Only the first 'l' is replaced due to count=1.",
      "1": "Wrong. That replaces two l's.",
      "2": "Wrong. That replaces all l's.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('  x  '.strip())",
    "options": [
      "'x'",
      "x",
      "  x  ",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. print doesn't include quotes.",
      "1": "Correct. strip removes surrounding whitespace; print shows x.",
      "2": "Wrong. strip removes whitespace.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'[::-1])",
    "options": [
      "abc",
      "cba",
      "bac",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It reverses.",
      "1": "Correct. Step -1 reverses the string.",
      "2": "Wrong. That's not full reverse.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('x' in 'exam')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Membership test checks substring presence.",
      "1": "Wrong. 'exam' contains 'x'.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Regex",
    "prompt": "Which function returns an iterator of match objects?",
    "options": [
      "re.match",
      "re.search",
      "re.finditer",
      "re.findall"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. match checks only at the start and returns one match or None.",
      "1": "Wrong. search returns one match or None.",
      "2": "Correct. re.finditer returns an iterator of match objects.",
      "3": "Wrong. findall returns strings/tuples, not match objects."
    },
    "ikm_pdf_mapping": "Python Regular Expression Usage"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('\u03c0'.encode('utf-8'))",
    "options": [
      "'\u03c0'",
      "b'\\xcf\\x80'",
      "b'\u03c0'",
      "UnicodeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. encode returns bytes, not str.",
      "1": "Correct. UTF-8 encodes \u03c0 to the byte sequence \\xcf\\x80.",
      "2": "Wrong. bytes display escapes for non-ASCII.",
      "3": "Wrong. UTF-8 can encode \u03c0."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a\\nb'.splitlines())",
    "options": [
      "['a\\nb']",
      "['a', 'b']",
      "['a', 'b', '']",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It splits into two lines.",
      "1": "Correct. splitlines splits on line boundaries.",
      "2": "Wrong. There is no trailing newline.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a' < 'aa')",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Lexicographically, shorter prefix comes first.",
      "1": "Wrong. 'a' is a prefix of 'aa', so it compares smaller.",
      "2": "Wrong. Valid comparison.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('{}'.format(5))",
    "options": [
      "5",
      "'5'",
      "{}",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. format inserts 5 into the placeholder and produces '5', which prints as 5.",
      "1": "Wrong. print doesn't include quotes.",
      "2": "Wrong. Placeholder is replaced.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a,b,c'.partition(','))",
    "options": [
      "('a', ',', 'b,c')",
      "['a', ',', 'b,c']",
      "('a,b,c')",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. partition splits into (head, sep, tail) at first occurrence.",
      "1": "Wrong. It returns a tuple.",
      "2": "Wrong. It splits at the separator.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('a,b,c'.rpartition(','))",
    "options": [
      "('a,b', ',', 'c')",
      "('a', ',', 'b,c')",
      "('a,b,c', ',', '')",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. rpartition splits at the last occurrence.",
      "1": "Wrong. That's partition, not rpartition.",
      "2": "Wrong. There's content after the last comma.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('ab' * 0)",
    "options": [
      "ab",
      "",
      "0",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's repeated zero times.",
      "1": "Correct. Repeating zero times yields empty string.",
      "2": "Wrong. It doesn't stringify the multiplier.",
      "3": "Wrong. Valid operation."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Strings",
    "prompt": "What does this print?\n\nprint('abc'.startswith('a'))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. It starts with 'a'.",
      "1": "Wrong. 'abc' does start with 'a'.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Strings"
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(x, acc=None):\n    if acc is None:\n        acc = []\n    acc.append(x)\n    return acc\n\nprint(f(1))\nprint(f(2))",
    "options": [
      "[1] then [2]",
      "[1] then [1, 2]",
      "[] then [2]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Using None avoids the mutable-default pitfall; each call gets a fresh list.",
      "1": "Wrong. That happens with a mutable default list.",
      "2": "Wrong. First call appends 1.",
      "3": "Wrong. Valid code."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 1\n\ndef f():\n    global x\n    x = 2\n\nf()\nprint(x)",
    "options": [
      "1",
      "2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. global updates x.",
      "1": "Correct. global makes assignment affect the module-level x.",
      "2": "Wrong. No read-before-assign issue.",
      "3": "Wrong. x exists."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\ndef outer():\n    x = 'a'\n    def inner():\n        nonlocal x\n        x = 'b'\n    inner()\n    return x\n\nprint(outer())",
    "options": [
      "a",
      "b",
      "UnboundLocalError",
      "SyntaxError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. inner changes it.",
      "1": "Correct. nonlocal rebinds x in the enclosing scope to 'b'.",
      "2": "Wrong. nonlocal prevents that error.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    int('x')\nexcept ValueError:\n    print('bad')\nelse:\n    print('ok')",
    "options": [
      "bad",
      "ok",
      "bad\\nok",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. int('x') raises ValueError, so except runs and else does not.",
      "1": "Wrong. It fails to parse.",
      "2": "Wrong. else only runs if no exception.",
      "3": "Wrong. ValueError is raised, not TypeError."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    print('try')\nfinally:\n    print('finally')",
    "options": [
      "try",
      "finally",
      "try\\nfinally",
      "No output"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. finally also prints.",
      "1": "Wrong. try also prints.",
      "2": "Correct. finally always runs after the try block.",
      "3": "Wrong. Both print."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    1/0\nexcept ZeroDivisionError:\n    print('z')\nfinally:\n    print('f')",
    "options": [
      "z\\nf",
      "f only",
      "z only",
      "Raises ZeroDivisionError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. except handles it, then finally runs.",
      "1": "Wrong. except prints z too.",
      "2": "Wrong. finally always runs.",
      "3": "Wrong. Exception is handled."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    raise KeyError('k')\nexcept KeyError as e:\n    print(e.args[0])",
    "options": [
      "k",
      "'k'",
      "KeyError",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. args[0] is the string passed to KeyError.",
      "1": "Wrong. Printing args[0] prints k (no quotes).",
      "2": "Wrong. It's handled.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(*args):\n    return len(args)\n\nprint(f(1,2,3))",
    "options": [
      "0",
      "1",
      "3",
      "TypeError"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. There are args.",
      "1": "Wrong. There are 3.",
      "2": "Correct. *args collects positional arguments into a tuple of length 3.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(**kwargs):\n    return 'x' in kwargs\n\nprint(f(x=1))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. **kwargs collects keyword args into a dict with key 'x'.",
      "1": "Wrong. 'x' is present.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\nprint((lambda x: x+1)(2))",
    "options": [
      "2",
      "3",
      "TypeError",
      "<function ...>"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It adds 1.",
      "1": "Correct. The lambda is called with 2 and returns 3.",
      "2": "Wrong. Valid call.",
      "3": "Wrong. It's invoked, so it prints the result."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Functions",
    "prompt": "What does this print?\n\ndef f(a, b, /, c):\n    return a, b, c\n\nprint(f(1, 2, c=3))",
    "options": [
      "(1, 2, 3)",
      "TypeError",
      "(1, 3, 2)",
      "SyntaxError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. a and b are positional-only; c can be passed by keyword.",
      "1": "Wrong. This call respects positional-only params.",
      "2": "Wrong. Order is (a,b,c).",
      "3": "Wrong. This is valid Python 3.8+ syntax."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Functions",
    "prompt": "What happens?\n\ndef f(a, *, b):\n    return a + b\n\nf(1, 2)",
    "options": [
      "Returns 3",
      "TypeError",
      "SyntaxError",
      "Returns 12"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. b must be keyword.",
      "1": "Correct. b is keyword-only, so passing it positionally raises TypeError.",
      "2": "Wrong. Definition is valid.",
      "3": "Wrong. Not string concatenation."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Exceptions",
    "prompt": "What does this print?\n\ntry:\n    {}['x']\nexcept KeyError:\n    print('missing')",
    "options": [
      "missing",
      "KeyError",
      "None",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Accessing a missing dict key raises KeyError, which is caught.",
      "1": "Wrong. It's handled by except.",
      "2": "Wrong. It prints missing.",
      "3": "Wrong. The error is KeyError."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Exceptions",
    "prompt": "What is printed?\n\ntry:\n    pass\nexcept Exception:\n    print('except')\nelse:\n    print('else')",
    "options": [
      "except",
      "else",
      "except\\nelse",
      "No output"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. except doesn't run without an exception.",
      "1": "Correct. No exception occurs, so else runs.",
      "2": "Wrong. except won't run.",
      "3": "Wrong. else prints."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\nx = 1\n\ndef f():\n    return x\n\nx = 2\nprint(f())",
    "options": [
      "1",
      "2",
      "UnboundLocalError",
      "NameError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. x was reassigned before calling f.",
      "1": "Correct. f reads the global name x at call time; x is 2 then.",
      "2": "Wrong. No local assignment in f.",
      "3": "Wrong. x exists."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Scope",
    "prompt": "What does this print?\n\ndef f():\n    x = 1\n    def g():\n        return x\n    return g\n\nh = f()\nprint(h())",
    "options": [
      "1",
      "NameError",
      "UnboundLocalError",
      "<function ...>"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. g closes over x from f's scope.",
      "1": "Wrong. x is captured in the closure.",
      "2": "Wrong. x is assigned before use.",
      "3": "Wrong. h() calls g and returns 1."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Closures",
    "prompt": "How do you make each lambda capture the loop value (best answer)?\n\nfuncs=[]\nfor i in range(3):\n    funcs.append(lambda: i)",
    "options": [
      "Use lambda i=i: i",
      "Use nonlocal i",
      "Use global i",
      "Use i.copy()"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Default args bind the current value at definition time.",
      "1": "Wrong. nonlocal is for assignment to an enclosing binding.",
      "2": "Wrong. global doesn't create per-iteration bindings.",
      "3": "Wrong. i is an int and has no copy() effect here."
    },
    "ikm_pdf_mapping": "Core Python Functions"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport itertools\nprint(list(itertools.islice(itertools.count(10), 3)))",
    "options": [
      "[10, 11, 12]",
      "[10, 11, 12, 13]",
      "[0, 1, 2]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. count(10) yields 10,11,12,... and islice takes the first 3.",
      "1": "Wrong. islice(..., 3) takes 3 items.",
      "2": "Wrong. It starts from 10.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.chain([1,2],[3]) produce when converted to list?",
    "options": [
      "[1, 2, 3]",
      "[[1,2],[3]]",
      "[1,2,[3]]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. chain concatenates iterables sequentially.",
      "1": "Wrong. It doesn't nest lists.",
      "2": "Wrong. It yields elements, not sublists.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Itertools",
    "prompt": "What does itertools.product([1,2], ['a','b']) produce (as a list)?",
    "options": [
      "[(1,'a'), (1,'b'), (2,'a'), (2,'b')]",
      "[(1,'a'), (2,'b')]",
      "[(1,2), ('a','b')]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. product is the Cartesian product.",
      "1": "Wrong. That's not all pairs.",
      "2": "Wrong. It pairs elements across iterables.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport math\nprint(math.floor(-1.2))",
    "options": [
      "-1",
      "-2",
      "1",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's truncation toward zero.",
      "1": "Correct. floor rounds toward negative infinity; floor(-1.2) is -2.",
      "2": "Wrong. Sign is negative.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(round(2.5))",
    "options": [
      "2",
      "3",
      "2.5",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Python uses bankers rounding: ties go to even, so 2.5 rounds to 2.",
      "1": "Wrong. That would be round-half-up, not Python's default.",
      "2": "Wrong. round returns an int here.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nprint(divmod(7, 3))",
    "options": [
      "(2, 1)",
      "(1, 2)",
      "(7, 3)",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. divmod returns (quotient, remainder).",
      "1": "Wrong. Order is (quotient, remainder).",
      "2": "Wrong. It computes quotient and remainder.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Typing",
    "prompt": "What does list[int] mean (Python 3.9+)?",
    "options": [
      "A list of ints (type hint)",
      "A list literal",
      "Runtime enforcement of int",
      "SyntaxError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. It's a generic type hint meaning list of int.",
      "1": "Wrong. That's [] syntax.",
      "2": "Wrong. Type hints don't enforce at runtime by default.",
      "3": "Wrong. It's valid in 3.9+."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Typing",
    "prompt": "What does this print?\n\nfrom typing import Optional\nx: Optional[int] = None\nprint(x is None)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. x is set to None.",
      "1": "Wrong. x is None.",
      "2": "Wrong. No exception.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Asyncio",
    "prompt": "What does this return?\n\nasync def f():\n    return 1\n\nx = f()\nprint(type(x).__name__)",
    "options": [
      "coroutine",
      "int",
      "Task",
      "function"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Calling an async function returns a coroutine object.",
      "1": "Wrong. It doesn't run until awaited.",
      "2": "Wrong. It isn't a Task unless scheduled.",
      "3": "Wrong. It's a coroutine object, not a function."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def __init__(self):\n        self.x = 1\n\na = A()\nprint(hasattr(a, 'x'))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __init__ sets self.x, so attribute exists.",
      "1": "Wrong. x was created.",
      "2": "Wrong. hasattr works here.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def __repr__(self):\n        return 'A()'\n\nprint(A())",
    "options": [
      "<__main__.A object ...>",
      "A()",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __repr__ overrides default repr.",
      "1": "Correct. print uses __str__ or falls back to __repr__.",
      "2": "Wrong. Valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def __iter__(self):\n        return iter([1,2])\n\nprint(list(A()))",
    "options": [
      "[1, 2]",
      "[]",
      "TypeError",
      "[<A ...>]"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. __iter__ returns an iterator over [1,2].",
      "1": "Wrong. It yields two items.",
      "2": "Wrong. list() can iterate it.",
      "3": "Wrong. It iterates, not wraps."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "Dataclasses",
    "prompt": "What does this print?\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass P:\n    x: int\n\np = P(1)\nprint(p.x)",
    "options": [
      "1",
      "x",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. dataclass generates an __init__ and stores x.",
      "1": "Wrong. It prints the value 1.",
      "2": "Wrong. This is valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Python Classes"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport pathlib\np = pathlib.Path('a') / 'b'\nprint(str(p))",
    "options": [
      "a/b",
      "a\\b",
      "('a','b')",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Path joining with / builds a path like a/b (rendered with OS separator when stringified).",
      "1": "Wrong. On Windows it may display backslashes; but in many environments it's 'a/b'.",
      "2": "Wrong. It's a Path, not a tuple.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nfrom collections import Counter\nprint(Counter('aab')['a'])",
    "options": [
      "1",
      "2",
      "3",
      "KeyError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. 'a' appears twice.",
      "1": "Correct. Counter counts occurrences; 'a' appears twice.",
      "2": "Wrong. There are only two.",
      "3": "Wrong. Missing keys default to 0, and this key exists."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nfrom collections import defaultdict\n\nd = defaultdict(int)\nprint(d['missing'])",
    "options": [
      "0",
      "None",
      "KeyError",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. defaultdict(int) uses int() -> 0 for missing keys and inserts it.",
      "1": "Wrong. Default is int(), which is 0.",
      "2": "Wrong. defaultdict doesn't raise for missing keys.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport datetime as dt\nprint(type(dt.date.today()).__name__)",
    "options": [
      "datetime",
      "date",
      "time",
      "str"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's dt.datetime.",
      "1": "Correct. dt.date.today() returns a date object.",
      "2": "Wrong. That's dt.time.",
      "3": "Wrong. It's not a string."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Security",
    "prompt": "Which is TRUE about subprocess.run(..., shell=True)?",
    "options": [
      "Always safe",
      "Can be vulnerable to shell injection if inputs are untrusted",
      "Disables command execution",
      "Requires asyncio"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. It's not always safe.",
      "1": "Correct. shell=True can interpret input via a shell, increasing injection risk with untrusted strings.",
      "2": "Wrong. It still executes commands.",
      "3": "Wrong. asyncio isn't required."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Testing",
    "prompt": "In unittest, what does setUp do?",
    "options": [
      "Runs once per test case class",
      "Runs before each test method",
      "Runs after each test method",
      "Is only for async tests"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. That's setUpClass.",
      "1": "Correct. setUp runs before each test method.",
      "2": "Wrong. That's tearDown.",
      "3": "Wrong. It's for all tests."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Performance",
    "prompt": "Which is usually faster for membership: x in set vs x in list (large collections)?",
    "options": [
      "List is faster",
      "Set is faster on average",
      "They are always identical",
      "Depends only on OS"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. Lists require scanning.",
      "1": "Correct. Set membership is O(1) average; list is O(n).",
      "2": "Wrong. Different algorithms.",
      "3": "Wrong. Not OS-dependent in that way."
    },
    "ikm_pdf_mapping": "Python Functional Programming"
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nprint(1e3 == 1000)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. 1e3 is 1000.0, numerically equal to 1000.",
      "1": "Wrong. They compare equal by value.",
      "2": "Wrong. Valid comparison.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Numerics",
    "prompt": "What does this print?\n\nimport decimal\nprint(decimal.Decimal('0.1') + decimal.Decimal('0.2') == decimal.Decimal('0.3'))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Decimal does exact base-10 arithmetic with these literals.",
      "1": "Wrong. With Decimal strings, this is exact.",
      "2": "Wrong. Valid.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "Core Python Control Flow / Python Precedence and Associativity"
  },
  {
    "topic": "Bitwise",
    "prompt": "What does this print?\n\nprint(5 & 3)",
    "options": [
      "1",
      "4",
      "7",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. 5 (101) & 3 (011) = 001 -> 1.",
      "1": "Wrong. That's 5 & 4 style outcome.",
      "2": "Wrong. That's OR (|) result.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Precedence and Associativity"
  },
  {
    "topic": "Bitwise",
    "prompt": "What does this print?\n\nprint(5 | 2)",
    "options": [
      "7",
      "3",
      "1",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. 5 (101) | 2 (010) = 111 -> 7.",
      "1": "Wrong. That's XOR for 1? no.",
      "2": "Wrong. Not AND.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Precedence and Associativity"
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this print?\n\nprint([x*x for x in range(4) if x%2==0])",
    "options": [
      "[0, 4]",
      "[1, 9]",
      "[0, 1, 4, 9]",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Squares of even x in 0..3 are 0 and 4.",
      "1": "Wrong. Those are odd squares.",
      "2": "Wrong. Filter keeps only evens.",
      "3": "Wrong. Valid."
    },
    "ikm_pdf_mapping": "Python Comprehensions"
  },
  {
    "topic": "Generators",
    "prompt": "What does this print?\n\ng = (x*x for x in range(3))\nprint(next(g), list(g))",
    "options": [
      "0 [1, 4]",
      "0 [0, 1, 4]",
      "1 [4]",
      "StopIteration"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. next yields 0, then the generator continues with remaining 1 and 4.",
      "1": "Wrong. 0 was already consumed.",
      "2": "Wrong. First next(g) yields 0, not 1.",
      "3": "Wrong. It isn't exhausted after one next."
    },
    "ikm_pdf_mapping": "Python Generators and Coroutines"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport json\nprint(json.loads('\"x\"'))",
    "options": [
      "x",
      "'x'",
      "\"x\"",
      "TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. json.loads parses the JSON string into the Python str 'x', which prints as x.",
      "1": "Wrong. print doesn't include quotes.",
      "2": "Wrong. That's the JSON literal representation.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "Stdlib",
    "prompt": "What does this print?\n\nimport random\nrandom.seed(0)\nprint(isinstance(random.random(), float))",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. random.random() returns a float in [0.0, 1.0).",
      "1": "Wrong. It returns float.",
      "2": "Wrong. Valid.",
      "3": "Wrong. Deterministic for type."
    },
    "ikm_pdf_mapping": "Python Modules and Imports"
  },
  {
    "topic": "OOP",
    "prompt": "What does this print?\n\nclass A:\n    def f(self):\n        return 'A'\n\nclass B(A):\n    pass\n\nprint(B().f())",
    "options": [
      "A",
      "B",
      "AB",
      "AttributeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. B inherits f from A unchanged.",
      "1": "Wrong. B doesn't override f.",
      "2": "Wrong. No concatenation occurs.",
      "3": "Wrong. Method exists via inheritance."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "References",
    "prompt": "What does this print?\n\nx = [1,2]\ny = x\nx = x + [3]\nprint(y)",
    "options": [
      "[1,2,3]",
      "[1,2]",
      "[3]",
      "TypeError"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. y was not updated because x was rebound, not mutated.",
      "1": "Correct. x + [3] creates a new list and rebinds x; y still points to the original [1,2].",
      "2": "Wrong. y references the original list.",
      "3": "Wrong. This is valid."
    },
    "ikm_pdf_mapping": "Python Lists and Tuples"
  },
  {
    "topic": "File IO",
    "prompt": "What does this print?\n\nwith open('test.txt', 'w') as f:\n    f.write('hi')\nprint(f.closed)",
    "options": [
      "True",
      "False",
      "Raises ValueError",
      "Depends on OS"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Files opened with 'with' are closed automatically after the block.",
      "1": "Wrong. The context manager closes the file.",
      "2": "Wrong. Accessing f.closed is valid.",
      "3": "Wrong. Behavior is deterministic."
    },
    "ikm_pdf_mapping": "Core Python File I/O"
  },
  {
    "topic": "Regex",
    "prompt": "What does this return?\n\nimport re\nre.findall(r'\\d+', 'a1b22c333')",
    "options": [
      "['1', '22', '333']",
      "[1, 22, 333]",
      "['a', 'b', 'c']",
      "Raises ValueError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. findall returns all digit substrings as strings.",
      "1": "Wrong. Results are strings, not ints.",
      "2": "Wrong. Regex targets digits.",
      "3": "Wrong. Valid regex usage."
    },
    "ikm_pdf_mapping": "Python Regular Expression Usage"
  },
  {
    "topic": "Concurrency",
    "prompt": "Which scenario benefits most from threading in CPython?",
    "options": [
      "CPU-bound numeric computation",
      "Heavy numerical loops",
      "I/O-bound tasks like network requests",
      "Matrix multiplication"
    ],
    "correct": [
      2
    ],
    "explanations": {
      "0": "Wrong. CPU-bound work is limited by the GIL.",
      "1": "Wrong. Still CPU-bound.",
      "2": "Correct. I/O-bound threads can overlap waiting time.",
      "3": "Wrong. CPU-bound."
    },
    "ikm_pdf_mapping": "Python Concurrency"
  },
  {
    "topic": "Comprehensions",
    "prompt": "What does this produce?\n\n[(i, j) for i in range(2) for j in range(2)]",
    "options": [
      "[(0,0), (0,1), (1,0), (1,1)]",
      "[(0,1), (1,0)]",
      "[(0,0), (1,1)]",
      "Raises TypeError"
    ],
    "correct": [
      0
    ],
    "explanations": {
      "0": "Correct. Nested comprehensions expand left to right.",
      "1": "Wrong. Missing pairs.",
      "2": "Wrong. That's diagonal only.",
      "3": "Wrong. Valid comprehension."
    },
    "ikm_pdf_mapping": "Python Comprehensions"
  },
  {
    "topic": "Decorators",
    "prompt": "What is the purpose of functools.wraps inside a decorator?",
    "options": [
      "Improve performance",
      "Preserve metadata like __name__ and __doc__",
      "Enable recursion",
      "Make decorators thread-safe"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. wraps is not for performance.",
      "1": "Correct. wraps copies metadata from the wrapped function.",
      "2": "Wrong. Recursion is unrelated.",
      "3": "Wrong. Thread safety is unrelated."
    },
    "ikm_pdf_mapping": "Python Formatting and Decorators"
  },
  {
    "topic": "Generators",
    "prompt": "What keyword allows sending a value into a generator?",
    "options": [
      "yield from",
      "send",
      "next",
      "throw"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. yield from delegates iteration.",
      "1": "Correct. send(value) resumes a generator and injects a value.",
      "2": "Wrong. next sends None.",
      "3": "Wrong. throw raises an exception inside the generator."
    },
    "ikm_pdf_mapping": "Python Generators and Coroutines"
  },
  {
    "topic": "OOP",
    "prompt": "Which method is called when accessing a missing attribute?",
    "options": [
      "__getattribute__",
      "__getattr__",
      "__missing__",
      "__lookup__"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. __getattribute__ runs for all attribute access.",
      "1": "Correct. __getattr__ is called only if attribute is not found.",
      "2": "Wrong. __missing__ is for dict subclasses.",
      "3": "Wrong. Not a Python hook."
    },
    "ikm_pdf_mapping": "Python Classes / Python Inheritance / Python Encapsulation"
  },
  {
    "topic": "Precedence",
    "prompt": "What does this print?\n\nprint(not True or False)",
    "options": [
      "True",
      "False",
      "TypeError",
      "Depends"
    ],
    "correct": [
      1
    ],
    "explanations": {
      "0": "Wrong. not True is False; False or False is False.",
      "1": "Correct. not has higher precedence than or.",
      "2": "Wrong. Valid expression.",
      "3": "Wrong. Deterministic."
    },
    "ikm_pdf_mapping": "General Python 3 Knowledge"
  }
]